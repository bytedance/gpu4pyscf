#include <cuda.h>
#include "vhf.cuh"
#include "rys_roots.cu"
#include "create_tasks.cu"


template<typename FloatType>
__device__ static
void _rys_jk_0000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 1;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    gout0 += 1 * fac * wt;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_0000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_0000<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_1000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 1;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    gout0 += trr_10x * fac * wt;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += 1 * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += 1 * fac * trr_10z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_1000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_1000<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_1010(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    gout0 += trr_11x * fac * wt;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += trr_01x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += trr_01x * fac * trr_10z;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout3 += trr_10x * trr_01y * wt;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout4 += 1 * trr_11y * wt;
                    gout5 += 1 * trr_01y * trr_10z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout6 += trr_10x * fac * trr_01z;
                    gout7 += 1 * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout8 += 1 * fac * trr_11z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_1010(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_1010<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_1011(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType trr_12x = cpx * trr_11x + 1*b01 * trr_10x + 1*b00 * trr_01x;
                    const FloatType hrr_1011x = trr_12x - xlxk * trr_11x;
                    gout0 += hrr_1011x * fac * wt;
                    const FloatType trr_02x = cpx * trr_01x + 1*b01 * 1;
                    const FloatType hrr_0011x = trr_02x - xlxk * trr_01x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_0011x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_0011x * fac * trr_10z;
                    const FloatType hrr_1001x = trr_11x - xlxk * trr_10x;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout3 += hrr_1001x * trr_01y * wt;
                    const FloatType hrr_0001x = trr_01x - xlxk * 1;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout4 += hrr_0001x * trr_11y * wt;
                    gout5 += hrr_0001x * trr_01y * trr_10z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout6 += hrr_1001x * fac * trr_01z;
                    gout7 += hrr_0001x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout8 += hrr_0001x * fac * trr_11z;
                    const FloatType hrr_0001y = trr_01y - ylyk * fac;
                    gout9 += trr_11x * hrr_0001y * wt;
                    const FloatType hrr_1001y = trr_11y - ylyk * trr_10y;
                    gout10 += trr_01x * hrr_1001y * wt;
                    gout11 += trr_01x * hrr_0001y * trr_10z;
                    const FloatType trr_02y = cpy * trr_01y + 1*b01 * fac;
                    const FloatType hrr_0011y = trr_02y - ylyk * trr_01y;
                    gout12 += trr_10x * hrr_0011y * wt;
                    const FloatType trr_12y = cpy * trr_11y + 1*b01 * trr_10y + 1*b00 * trr_01y;
                    const FloatType hrr_1011y = trr_12y - ylyk * trr_11y;
                    gout13 += 1 * hrr_1011y * wt;
                    gout14 += 1 * hrr_0011y * trr_10z;
                    gout15 += trr_10x * hrr_0001y * trr_01z;
                    gout16 += 1 * hrr_1001y * trr_01z;
                    gout17 += 1 * hrr_0001y * trr_11z;
                    const FloatType hrr_0001z = trr_01z - zlzk * wt;
                    gout18 += trr_11x * fac * hrr_0001z;
                    gout19 += trr_01x * trr_10y * hrr_0001z;
                    const FloatType hrr_1001z = trr_11z - zlzk * trr_10z;
                    gout20 += trr_01x * fac * hrr_1001z;
                    gout21 += trr_10x * trr_01y * hrr_0001z;
                    gout22 += 1 * trr_11y * hrr_0001z;
                    gout23 += 1 * trr_01y * hrr_1001z;
                    const FloatType trr_02z = cpz * trr_01z + 1*b01 * wt;
                    const FloatType hrr_0011z = trr_02z - zlzk * trr_01z;
                    gout24 += trr_10x * fac * hrr_0011z;
                    gout25 += 1 * trr_10y * hrr_0011z;
                    const FloatType trr_12z = cpz * trr_11z + 1*b01 * trr_10z + 1*b00 * trr_01z;
                    const FloatType hrr_1011z = trr_12z - zlzk * trr_11z;
                    gout26 += 1 * fac * hrr_1011z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_1011(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_1011<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_1100(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    gout0 += hrr_1100x * fac * wt;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_0100x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_0100x * fac * trr_10z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout3 += trr_10x * hrr_0100y * wt;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout4 += 1 * hrr_1100y * wt;
                    gout5 += 1 * hrr_0100y * trr_10z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout6 += trr_10x * fac * hrr_0100z;
                    gout7 += 1 * trr_10y * hrr_0100z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout8 += 1 * fac * hrr_1100z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+0)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_1100(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_1100<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_1110(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType hrr_1110x = trr_21x - xjxi * trr_11x;
                    gout0 += hrr_1110x * fac * wt;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType hrr_0110x = trr_11x - xjxi * trr_01x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_0110x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_0110x * fac * trr_10z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout3 += trr_11x * hrr_0100y * wt;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout4 += trr_01x * hrr_1100y * wt;
                    gout5 += trr_01x * hrr_0100y * trr_10z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout6 += trr_11x * fac * hrr_0100z;
                    gout7 += trr_01x * trr_10y * hrr_0100z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout8 += trr_01x * fac * hrr_1100z;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout9 += hrr_1100x * trr_01y * wt;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout10 += hrr_0100x * trr_11y * wt;
                    gout11 += hrr_0100x * trr_01y * trr_10z;
                    const FloatType hrr_0110y = trr_11y - yjyi * trr_01y;
                    gout12 += trr_10x * hrr_0110y * wt;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    const FloatType hrr_1110y = trr_21y - yjyi * trr_11y;
                    gout13 += 1 * hrr_1110y * wt;
                    gout14 += 1 * hrr_0110y * trr_10z;
                    gout15 += trr_10x * trr_01y * hrr_0100z;
                    gout16 += 1 * trr_11y * hrr_0100z;
                    gout17 += 1 * trr_01y * hrr_1100z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout18 += hrr_1100x * fac * trr_01z;
                    gout19 += hrr_0100x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout20 += hrr_0100x * fac * trr_11z;
                    gout21 += trr_10x * hrr_0100y * trr_01z;
                    gout22 += 1 * hrr_1100y * trr_01z;
                    gout23 += 1 * hrr_0100y * trr_11z;
                    const FloatType hrr_0110z = trr_11z - zjzi * trr_01z;
                    gout24 += trr_10x * fac * hrr_0110z;
                    gout25 += 1 * trr_10y * hrr_0110z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    const FloatType hrr_1110z = trr_21z - zjzi * trr_11z;
                    gout26 += 1 * fac * hrr_1110z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_1110(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_1110<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_1111(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    FloatType gout36;
    FloatType gout37;
    FloatType gout38;
    FloatType gout39;
    FloatType gout40;
    FloatType gout41;
    FloatType gout42;
    FloatType gout43;
    FloatType gout44;
    FloatType gout45;
    FloatType gout46;
    FloatType gout47;
    FloatType gout48;
    FloatType gout49;
    FloatType gout50;
    FloatType gout51;
    FloatType gout52;
    FloatType gout53;
    FloatType gout54;
    FloatType gout55;
    FloatType gout56;
    FloatType gout57;
    FloatType gout58;
    FloatType gout59;
    FloatType gout60;
    FloatType gout61;
    FloatType gout62;
    FloatType gout63;
    FloatType gout64;
    FloatType gout65;
    FloatType gout66;
    FloatType gout67;
    FloatType gout68;
    FloatType gout69;
    FloatType gout70;
    FloatType gout71;
    FloatType gout72;
    FloatType gout73;
    FloatType gout74;
    FloatType gout75;
    FloatType gout76;
    FloatType gout77;
    FloatType gout78;
    FloatType gout79;
    FloatType gout80;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        gout36 = 0;
        gout37 = 0;
        gout38 = 0;
        gout39 = 0;
        gout40 = 0;
        gout41 = 0;
        gout42 = 0;
        gout43 = 0;
        gout44 = 0;
        gout45 = 0;
        gout46 = 0;
        gout47 = 0;
        gout48 = 0;
        gout49 = 0;
        gout50 = 0;
        gout51 = 0;
        gout52 = 0;
        gout53 = 0;
        gout54 = 0;
        gout55 = 0;
        gout56 = 0;
        gout57 = 0;
        gout58 = 0;
        gout59 = 0;
        gout60 = 0;
        gout61 = 0;
        gout62 = 0;
        gout63 = 0;
        gout64 = 0;
        gout65 = 0;
        gout66 = 0;
        gout67 = 0;
        gout68 = 0;
        gout69 = 0;
        gout70 = 0;
        gout71 = 0;
        gout72 = 0;
        gout73 = 0;
        gout74 = 0;
        gout75 = 0;
        gout76 = 0;
        gout77 = 0;
        gout78 = 0;
        gout79 = 0;
        gout80 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType trr_22x = cpx * trr_21x + 1*b01 * trr_20x + 2*b00 * trr_11x;
                    const FloatType hrr_2011x = trr_22x - xlxk * trr_21x;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType trr_12x = cpx * trr_11x + 1*b01 * trr_10x + 1*b00 * trr_01x;
                    const FloatType hrr_1011x = trr_12x - xlxk * trr_11x;
                    const FloatType hrr_1111x = hrr_2011x - xjxi * hrr_1011x;
                    gout0 += hrr_1111x * fac * wt;
                    const FloatType trr_02x = cpx * trr_01x + 1*b01 * 1;
                    const FloatType hrr_0011x = trr_02x - xlxk * trr_01x;
                    const FloatType hrr_0111x = hrr_1011x - xjxi * hrr_0011x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_0111x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_0111x * fac * trr_10z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout3 += hrr_1011x * hrr_0100y * wt;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout4 += hrr_0011x * hrr_1100y * wt;
                    gout5 += hrr_0011x * hrr_0100y * trr_10z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout6 += hrr_1011x * fac * hrr_0100z;
                    gout7 += hrr_0011x * trr_10y * hrr_0100z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout8 += hrr_0011x * fac * hrr_1100z;
                    const FloatType hrr_2001x = trr_21x - xlxk * trr_20x;
                    const FloatType hrr_1001x = trr_11x - xlxk * trr_10x;
                    const FloatType hrr_1101x = hrr_2001x - xjxi * hrr_1001x;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout9 += hrr_1101x * trr_01y * wt;
                    const FloatType hrr_0001x = trr_01x - xlxk * 1;
                    const FloatType hrr_0101x = hrr_1001x - xjxi * hrr_0001x;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout10 += hrr_0101x * trr_11y * wt;
                    gout11 += hrr_0101x * trr_01y * trr_10z;
                    const FloatType hrr_0110y = trr_11y - yjyi * trr_01y;
                    gout12 += hrr_1001x * hrr_0110y * wt;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    const FloatType hrr_1110y = trr_21y - yjyi * trr_11y;
                    gout13 += hrr_0001x * hrr_1110y * wt;
                    gout14 += hrr_0001x * hrr_0110y * trr_10z;
                    gout15 += hrr_1001x * trr_01y * hrr_0100z;
                    gout16 += hrr_0001x * trr_11y * hrr_0100z;
                    gout17 += hrr_0001x * trr_01y * hrr_1100z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout18 += hrr_1101x * fac * trr_01z;
                    gout19 += hrr_0101x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout20 += hrr_0101x * fac * trr_11z;
                    gout21 += hrr_1001x * hrr_0100y * trr_01z;
                    gout22 += hrr_0001x * hrr_1100y * trr_01z;
                    gout23 += hrr_0001x * hrr_0100y * trr_11z;
                    const FloatType hrr_0110z = trr_11z - zjzi * trr_01z;
                    gout24 += hrr_1001x * fac * hrr_0110z;
                    gout25 += hrr_0001x * trr_10y * hrr_0110z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    const FloatType hrr_1110z = trr_21z - zjzi * trr_11z;
                    gout26 += hrr_0001x * fac * hrr_1110z;
                    const FloatType hrr_1110x = trr_21x - xjxi * trr_11x;
                    const FloatType hrr_0001y = trr_01y - ylyk * fac;
                    gout27 += hrr_1110x * hrr_0001y * wt;
                    const FloatType hrr_0110x = trr_11x - xjxi * trr_01x;
                    const FloatType hrr_1001y = trr_11y - ylyk * trr_10y;
                    gout28 += hrr_0110x * hrr_1001y * wt;
                    gout29 += hrr_0110x * hrr_0001y * trr_10z;
                    const FloatType hrr_0101y = hrr_1001y - yjyi * hrr_0001y;
                    gout30 += trr_11x * hrr_0101y * wt;
                    const FloatType hrr_2001y = trr_21y - ylyk * trr_20y;
                    const FloatType hrr_1101y = hrr_2001y - yjyi * hrr_1001y;
                    gout31 += trr_01x * hrr_1101y * wt;
                    gout32 += trr_01x * hrr_0101y * trr_10z;
                    gout33 += trr_11x * hrr_0001y * hrr_0100z;
                    gout34 += trr_01x * hrr_1001y * hrr_0100z;
                    gout35 += trr_01x * hrr_0001y * hrr_1100z;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    const FloatType trr_02y = cpy * trr_01y + 1*b01 * fac;
                    const FloatType hrr_0011y = trr_02y - ylyk * trr_01y;
                    gout36 += hrr_1100x * hrr_0011y * wt;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType trr_12y = cpy * trr_11y + 1*b01 * trr_10y + 1*b00 * trr_01y;
                    const FloatType hrr_1011y = trr_12y - ylyk * trr_11y;
                    gout37 += hrr_0100x * hrr_1011y * wt;
                    gout38 += hrr_0100x * hrr_0011y * trr_10z;
                    const FloatType hrr_0111y = hrr_1011y - yjyi * hrr_0011y;
                    gout39 += trr_10x * hrr_0111y * wt;
                    const FloatType trr_22y = cpy * trr_21y + 1*b01 * trr_20y + 2*b00 * trr_11y;
                    const FloatType hrr_2011y = trr_22y - ylyk * trr_21y;
                    const FloatType hrr_1111y = hrr_2011y - yjyi * hrr_1011y;
                    gout40 += 1 * hrr_1111y * wt;
                    gout41 += 1 * hrr_0111y * trr_10z;
                    gout42 += trr_10x * hrr_0011y * hrr_0100z;
                    gout43 += 1 * hrr_1011y * hrr_0100z;
                    gout44 += 1 * hrr_0011y * hrr_1100z;
                    gout45 += hrr_1100x * hrr_0001y * trr_01z;
                    gout46 += hrr_0100x * hrr_1001y * trr_01z;
                    gout47 += hrr_0100x * hrr_0001y * trr_11z;
                    gout48 += trr_10x * hrr_0101y * trr_01z;
                    gout49 += 1 * hrr_1101y * trr_01z;
                    gout50 += 1 * hrr_0101y * trr_11z;
                    gout51 += trr_10x * hrr_0001y * hrr_0110z;
                    gout52 += 1 * hrr_1001y * hrr_0110z;
                    gout53 += 1 * hrr_0001y * hrr_1110z;
                    const FloatType hrr_0001z = trr_01z - zlzk * wt;
                    gout54 += hrr_1110x * fac * hrr_0001z;
                    gout55 += hrr_0110x * trr_10y * hrr_0001z;
                    const FloatType hrr_1001z = trr_11z - zlzk * trr_10z;
                    gout56 += hrr_0110x * fac * hrr_1001z;
                    gout57 += trr_11x * hrr_0100y * hrr_0001z;
                    gout58 += trr_01x * hrr_1100y * hrr_0001z;
                    gout59 += trr_01x * hrr_0100y * hrr_1001z;
                    const FloatType hrr_0101z = hrr_1001z - zjzi * hrr_0001z;
                    gout60 += trr_11x * fac * hrr_0101z;
                    gout61 += trr_01x * trr_10y * hrr_0101z;
                    const FloatType hrr_2001z = trr_21z - zlzk * trr_20z;
                    const FloatType hrr_1101z = hrr_2001z - zjzi * hrr_1001z;
                    gout62 += trr_01x * fac * hrr_1101z;
                    gout63 += hrr_1100x * trr_01y * hrr_0001z;
                    gout64 += hrr_0100x * trr_11y * hrr_0001z;
                    gout65 += hrr_0100x * trr_01y * hrr_1001z;
                    gout66 += trr_10x * hrr_0110y * hrr_0001z;
                    gout67 += 1 * hrr_1110y * hrr_0001z;
                    gout68 += 1 * hrr_0110y * hrr_1001z;
                    gout69 += trr_10x * trr_01y * hrr_0101z;
                    gout70 += 1 * trr_11y * hrr_0101z;
                    gout71 += 1 * trr_01y * hrr_1101z;
                    const FloatType trr_02z = cpz * trr_01z + 1*b01 * wt;
                    const FloatType hrr_0011z = trr_02z - zlzk * trr_01z;
                    gout72 += hrr_1100x * fac * hrr_0011z;
                    gout73 += hrr_0100x * trr_10y * hrr_0011z;
                    const FloatType trr_12z = cpz * trr_11z + 1*b01 * trr_10z + 1*b00 * trr_01z;
                    const FloatType hrr_1011z = trr_12z - zlzk * trr_11z;
                    gout74 += hrr_0100x * fac * hrr_1011z;
                    gout75 += trr_10x * hrr_0100y * hrr_0011z;
                    gout76 += 1 * hrr_1100y * hrr_0011z;
                    gout77 += 1 * hrr_0100y * hrr_1011z;
                    const FloatType hrr_0111z = hrr_1011z - zjzi * hrr_0011z;
                    gout78 += trr_10x * fac * hrr_0111z;
                    gout79 += 1 * trr_10y * hrr_0111z;
                    const FloatType trr_22z = cpz * trr_21z + 1*b01 * trr_20z + 2*b00 * trr_11z;
                    const FloatType hrr_2011z = trr_22z - zlzk * trr_21z;
                    const FloatType hrr_1111z = hrr_2011z - zjzi * hrr_1011z;
                    gout80 += 1 * fac * hrr_1111z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout27) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout45) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout54) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout63) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout72) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout30) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout57) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout66) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout75) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout60) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout69) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout78) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout28) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout46) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout55) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout64) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout73) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout58) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout67) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout76) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout61) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout70) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout79) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout29) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout47) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout56) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout65) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout74) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout41) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout59) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout68) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout77) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout62) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout71) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout80) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout30) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout39) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout41) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout42) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout44) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout48) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout49) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout50) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout51) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout52) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout53) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout54) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout55) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout56) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout57) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout58) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout59) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout60) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout61) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout62) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout63) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout64) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout65) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout66) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout67) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout68) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout69) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout70) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout71) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout72) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout73) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout74) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout75) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout76) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout77) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout78) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout79) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout80) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout30) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout54) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout63) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout72) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout57) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout66) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout75) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout60) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout69) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout78) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout55) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout64) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout73) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout58) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout67) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout76) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout61) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout70) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout79) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout41) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout56) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout65) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout74) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout59) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout68) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout77) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout62) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout71) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout80) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout45) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout28) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout46) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout29) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout47) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout54) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout63) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout72) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout55) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout64) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout73) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout56) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout65) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout74) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout41) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout57) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout66) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout75) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout58) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout67) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout76) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout59) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout68) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout77) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout33) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout60) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout69) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout78) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout61) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout70) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout79) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout62) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout71) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout80) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout54) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout57) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout60) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout63) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout66) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout42) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout69) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout72) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout48) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout75) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout51) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout78) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout55) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout58) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout61) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout64) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout67) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout70) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout73) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout49) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout76) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout52) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout79) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout56) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout5) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout59) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout62) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout65) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout41) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout68) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout44) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout71) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout74) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout23) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout50) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout77) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout53) * dm[(j0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout80) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout54) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout55) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout56) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout63) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout64) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout65) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout45) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout72) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout46) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout73) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout47) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout74) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout57) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout58) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout59) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout66) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout67) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout41) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout68) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout48) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout75) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout49) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout76) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout50) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout77) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout60) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout61) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout62) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout42) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout69) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout43) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout70) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout44) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout71) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout51) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout78) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout52) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout79) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout53) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout80) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_1111(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_1111<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    gout0 += trr_20x * fac * wt;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += trr_10x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += trr_10x * fac * trr_10z;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += 1 * trr_20y * wt;
                    gout4 += 1 * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += 1 * fac * trr_20z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_2000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2000<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2010(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    gout0 += trr_21x * fac * wt;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += trr_11x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += trr_11x * fac * trr_10z;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += trr_01x * trr_20y * wt;
                    gout4 += trr_01x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += trr_01x * fac * trr_20z;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout6 += trr_20x * trr_01y * wt;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout7 += trr_10x * trr_11y * wt;
                    gout8 += trr_10x * trr_01y * trr_10z;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    gout9 += 1 * trr_21y * wt;
                    gout10 += 1 * trr_11y * trr_10z;
                    gout11 += 1 * trr_01y * trr_20z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout12 += trr_20x * fac * trr_01z;
                    gout13 += trr_10x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout14 += trr_10x * fac * trr_11z;
                    gout15 += 1 * trr_20y * trr_01z;
                    gout16 += 1 * trr_10y * trr_11z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    gout17 += 1 * fac * trr_21z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_2010(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2010<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2011(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    FloatType gout36;
    FloatType gout37;
    FloatType gout38;
    FloatType gout39;
    FloatType gout40;
    FloatType gout41;
    FloatType gout42;
    FloatType gout43;
    FloatType gout44;
    FloatType gout45;
    FloatType gout46;
    FloatType gout47;
    FloatType gout48;
    FloatType gout49;
    FloatType gout50;
    FloatType gout51;
    FloatType gout52;
    FloatType gout53;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        gout36 = 0;
        gout37 = 0;
        gout38 = 0;
        gout39 = 0;
        gout40 = 0;
        gout41 = 0;
        gout42 = 0;
        gout43 = 0;
        gout44 = 0;
        gout45 = 0;
        gout46 = 0;
        gout47 = 0;
        gout48 = 0;
        gout49 = 0;
        gout50 = 0;
        gout51 = 0;
        gout52 = 0;
        gout53 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType trr_22x = cpx * trr_21x + 1*b01 * trr_20x + 2*b00 * trr_11x;
                    const FloatType hrr_2011x = trr_22x - xlxk * trr_21x;
                    gout0 += hrr_2011x * fac * wt;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType trr_12x = cpx * trr_11x + 1*b01 * trr_10x + 1*b00 * trr_01x;
                    const FloatType hrr_1011x = trr_12x - xlxk * trr_11x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_1011x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_1011x * fac * trr_10z;
                    const FloatType trr_02x = cpx * trr_01x + 1*b01 * 1;
                    const FloatType hrr_0011x = trr_02x - xlxk * trr_01x;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += hrr_0011x * trr_20y * wt;
                    gout4 += hrr_0011x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += hrr_0011x * fac * trr_20z;
                    const FloatType hrr_2001x = trr_21x - xlxk * trr_20x;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout6 += hrr_2001x * trr_01y * wt;
                    const FloatType hrr_1001x = trr_11x - xlxk * trr_10x;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout7 += hrr_1001x * trr_11y * wt;
                    gout8 += hrr_1001x * trr_01y * trr_10z;
                    const FloatType hrr_0001x = trr_01x - xlxk * 1;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    gout9 += hrr_0001x * trr_21y * wt;
                    gout10 += hrr_0001x * trr_11y * trr_10z;
                    gout11 += hrr_0001x * trr_01y * trr_20z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout12 += hrr_2001x * fac * trr_01z;
                    gout13 += hrr_1001x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout14 += hrr_1001x * fac * trr_11z;
                    gout15 += hrr_0001x * trr_20y * trr_01z;
                    gout16 += hrr_0001x * trr_10y * trr_11z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    gout17 += hrr_0001x * fac * trr_21z;
                    const FloatType hrr_0001y = trr_01y - ylyk * fac;
                    gout18 += trr_21x * hrr_0001y * wt;
                    const FloatType hrr_1001y = trr_11y - ylyk * trr_10y;
                    gout19 += trr_11x * hrr_1001y * wt;
                    gout20 += trr_11x * hrr_0001y * trr_10z;
                    const FloatType hrr_2001y = trr_21y - ylyk * trr_20y;
                    gout21 += trr_01x * hrr_2001y * wt;
                    gout22 += trr_01x * hrr_1001y * trr_10z;
                    gout23 += trr_01x * hrr_0001y * trr_20z;
                    const FloatType trr_02y = cpy * trr_01y + 1*b01 * fac;
                    const FloatType hrr_0011y = trr_02y - ylyk * trr_01y;
                    gout24 += trr_20x * hrr_0011y * wt;
                    const FloatType trr_12y = cpy * trr_11y + 1*b01 * trr_10y + 1*b00 * trr_01y;
                    const FloatType hrr_1011y = trr_12y - ylyk * trr_11y;
                    gout25 += trr_10x * hrr_1011y * wt;
                    gout26 += trr_10x * hrr_0011y * trr_10z;
                    const FloatType trr_22y = cpy * trr_21y + 1*b01 * trr_20y + 2*b00 * trr_11y;
                    const FloatType hrr_2011y = trr_22y - ylyk * trr_21y;
                    gout27 += 1 * hrr_2011y * wt;
                    gout28 += 1 * hrr_1011y * trr_10z;
                    gout29 += 1 * hrr_0011y * trr_20z;
                    gout30 += trr_20x * hrr_0001y * trr_01z;
                    gout31 += trr_10x * hrr_1001y * trr_01z;
                    gout32 += trr_10x * hrr_0001y * trr_11z;
                    gout33 += 1 * hrr_2001y * trr_01z;
                    gout34 += 1 * hrr_1001y * trr_11z;
                    gout35 += 1 * hrr_0001y * trr_21z;
                    const FloatType hrr_0001z = trr_01z - zlzk * wt;
                    gout36 += trr_21x * fac * hrr_0001z;
                    gout37 += trr_11x * trr_10y * hrr_0001z;
                    const FloatType hrr_1001z = trr_11z - zlzk * trr_10z;
                    gout38 += trr_11x * fac * hrr_1001z;
                    gout39 += trr_01x * trr_20y * hrr_0001z;
                    gout40 += trr_01x * trr_10y * hrr_1001z;
                    const FloatType hrr_2001z = trr_21z - zlzk * trr_20z;
                    gout41 += trr_01x * fac * hrr_2001z;
                    gout42 += trr_20x * trr_01y * hrr_0001z;
                    gout43 += trr_10x * trr_11y * hrr_0001z;
                    gout44 += trr_10x * trr_01y * hrr_1001z;
                    gout45 += 1 * trr_21y * hrr_0001z;
                    gout46 += 1 * trr_11y * hrr_1001z;
                    gout47 += 1 * trr_01y * hrr_2001z;
                    const FloatType trr_02z = cpz * trr_01z + 1*b01 * wt;
                    const FloatType hrr_0011z = trr_02z - zlzk * trr_01z;
                    gout48 += trr_20x * fac * hrr_0011z;
                    gout49 += trr_10x * trr_10y * hrr_0011z;
                    const FloatType trr_12z = cpz * trr_11z + 1*b01 * trr_10z + 1*b00 * trr_01z;
                    const FloatType hrr_1011z = trr_12z - zlzk * trr_11z;
                    gout50 += trr_10x * fac * hrr_1011z;
                    gout51 += 1 * trr_20y * hrr_0011z;
                    gout52 += 1 * trr_10y * hrr_1011z;
                    const FloatType trr_22z = cpz * trr_21z + 1*b01 * trr_20z + 2*b00 * trr_11z;
                    const FloatType hrr_2011z = trr_22z - zlzk * trr_21z;
                    gout53 += 1 * fac * hrr_2011z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout36) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout37) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout32) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout38) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout33) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout39) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout45) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout34) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout40) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout46) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout23) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout35) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout41) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout47) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout42) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout44) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout48) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout49) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout50) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout51) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout52) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout53) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout39) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout45) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout40) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout46) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout41) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout47) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout42) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout48) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout43) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout49) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout44) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout50) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout51) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout52) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout53) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout39) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout40) * dm[(i0+4)*nao+(l0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout41) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout42) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout43) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout44) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout45) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout46) * dm[(i0+4)*nao+(l0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout47) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout48) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout49) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout50) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout51) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout52) * dm[(i0+4)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout53) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2011(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2011<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2020(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType trr_22x = cpx * trr_21x + 1*b01 * trr_20x + 2*b00 * trr_11x;
                    gout0 += trr_22x * fac * wt;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType trr_12x = cpx * trr_11x + 1*b01 * trr_10x + 1*b00 * trr_01x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += trr_12x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += trr_12x * fac * trr_10z;
                    const FloatType trr_02x = cpx * trr_01x + 1*b01 * 1;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += trr_02x * trr_20y * wt;
                    gout4 += trr_02x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += trr_02x * fac * trr_20z;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout6 += trr_21x * trr_01y * wt;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout7 += trr_11x * trr_11y * wt;
                    gout8 += trr_11x * trr_01y * trr_10z;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    gout9 += trr_01x * trr_21y * wt;
                    gout10 += trr_01x * trr_11y * trr_10z;
                    gout11 += trr_01x * trr_01y * trr_20z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout12 += trr_21x * fac * trr_01z;
                    gout13 += trr_11x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout14 += trr_11x * fac * trr_11z;
                    gout15 += trr_01x * trr_20y * trr_01z;
                    gout16 += trr_01x * trr_10y * trr_11z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    gout17 += trr_01x * fac * trr_21z;
                    const FloatType trr_02y = cpy * trr_01y + 1*b01 * fac;
                    gout18 += trr_20x * trr_02y * wt;
                    const FloatType trr_12y = cpy * trr_11y + 1*b01 * trr_10y + 1*b00 * trr_01y;
                    gout19 += trr_10x * trr_12y * wt;
                    gout20 += trr_10x * trr_02y * trr_10z;
                    const FloatType trr_22y = cpy * trr_21y + 1*b01 * trr_20y + 2*b00 * trr_11y;
                    gout21 += 1 * trr_22y * wt;
                    gout22 += 1 * trr_12y * trr_10z;
                    gout23 += 1 * trr_02y * trr_20z;
                    gout24 += trr_20x * trr_01y * trr_01z;
                    gout25 += trr_10x * trr_11y * trr_01z;
                    gout26 += trr_10x * trr_01y * trr_11z;
                    gout27 += 1 * trr_21y * trr_01z;
                    gout28 += 1 * trr_11y * trr_11z;
                    gout29 += 1 * trr_01y * trr_21z;
                    const FloatType trr_02z = cpz * trr_01z + 1*b01 * wt;
                    gout30 += trr_20x * fac * trr_02z;
                    gout31 += trr_10x * trr_10y * trr_02z;
                    const FloatType trr_12z = cpz * trr_11z + 1*b01 * trr_10z + 1*b00 * trr_01z;
                    gout32 += trr_10x * fac * trr_12z;
                    gout33 += 1 * trr_20y * trr_02z;
                    gout34 += 1 * trr_10y * trr_12z;
                    const FloatType trr_22z = cpz * trr_21z + 1*b01 * trr_20z + 2*b00 * trr_11z;
                    gout35 += 1 * fac * trr_22z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout30) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout31) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout32) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout27) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout33) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout28) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout34) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout29) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout35) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(k0+4)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(k0+5)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(k0+4)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2020(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2020<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2021(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int gout_id = threadIdx.y;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *cicj_cache = (FloatType *)shared_memory;
    FloatType *rw = cicj_cache + iprim*jprim*TILE2 + sq_id;
    FloatType *gx = rw + nroots * 128;
    FloatType *gy = gx + 1152;
    FloatType *gz = gy + 1152;
    FloatType *rjri = gz + 1152;
    FloatType *rlrk = rjri + 192;
    FloatType *Rpq = rlrk + 192;

    int thread_id = 64 * gout_id + sq_id;
    int threads = 256;
    for (int n = thread_id; n < iprim*jprim*TILE2; n += threads) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        cicj_cache[sh_ij+ijp*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType s0, s1, s2;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += 64) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        if (gout_id == 0) {
            const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
            const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
            const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            rjri[0] = xjxi;
            rjri[64] = yjyi;
            rjri[128] = zjzi;
            rlrk[0] = xlxk;
            rlrk[64] = ylyk;
            rlrk[128] = zlzk;
        }
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            __syncthreads();
            if (gout_id == 0) {
                const FloatType xlxk = rlrk[0];
                const FloatType ylyk = rlrk[64];
                const FloatType zlzk = rlrk[128];
                const FloatType theta_kl = ak * al_akl;
                const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
                const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
                gx[0] = ckcl;
            }
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType aj_aij = aj / aij;
                const FloatType xij = static_cast<FloatType>(ri[0]) + rjri[0] * aj_aij;
                const FloatType yij = static_cast<FloatType>(ri[1]) + rjri[64] * aj_aij;
                const FloatType zij = static_cast<FloatType>(ri[2]) + rjri[128] * aj_aij;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + rlrk[0] * al_akl;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + rlrk[64] * al_akl;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + rlrk[128] * al_akl;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                __syncthreads();
                if (gout_id == 0) {
                    Rpq[0] = xpq;
                    Rpq[64] = ypq;
                    Rpq[128] = zpq;
                    const FloatType cicj = cicj_cache[sh_ij+ijp*TILE2];
                    gy[0] = cicj / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                }
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                __syncthreads();
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, 64, gout_id, 4);
                for (int irys = 0; irys < nroots; ++irys) {
                    __syncthreads();
                    const FloatType rt = rw[irys*128];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    for (int n = gout_id; n < 3; n += 4) {
                        if (n == 2) {
                            gz[0] = rw[irys*128+64];
                        }
                        FloatType *_gx = gx + n * 1152;
                        const FloatType xjxi = rjri[n*64];
                        const FloatType Rpa = xjxi * aj_aij;
                        const FloatType c0x = Rpa - rt_aij * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = c0x * s0;
                        _gx[64] = s1;
                        s2 = c0x * s1 + 1 * b10 * s0;
                        _gx[128] = s2;
                        const FloatType xlxk = rlrk[n*64];
                        const FloatType Rqc = xlxk * al_akl;
                        const FloatType cpx = Rqc + rt_akl * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = cpx * s0;
                        _gx[192] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        _gx[384] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = cpx*s1 + 2 * b01 *s0;
                        _gx[576] = s2;
                        s0 = _gx[64];
                        s1 = cpx * s0;
                        s1 += 1 * b00 * _gx[0];
                        _gx[256] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 1 * b00 * _gx[192];
                        _gx[448] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = cpx*s1 + 2 * b01 *s0;
                        s2 += 1 * b00 * _gx[384];
                        _gx[640] = s2;
                        s0 = _gx[128];
                        s1 = cpx * s0;
                        s1 += 2 * b00 * _gx[64];
                        _gx[320] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 2 * b00 * _gx[256];
                        _gx[512] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = cpx*s1 + 2 * b01 *s0;
                        s2 += 2 * b00 * _gx[448];
                        _gx[704] = s2;
                        s1 = _gx[576];
                        s0 = _gx[384];
                        _gx[960] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[192];
                        _gx[768] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[0];
                        _gx[576] = s1 - xlxk * s0;
                        s1 = _gx[640];
                        s0 = _gx[448];
                        _gx[1024] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[256];
                        _gx[832] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[64];
                        _gx[640] = s1 - xlxk * s0;
                        s1 = _gx[704];
                        s0 = _gx[512];
                        _gx[1088] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[320];
                        _gx[896] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[128];
                        _gx[704] = s1 - xlxk * s0;
                    }
                    __syncthreads();
                    switch (gout_id) {
                    case 0:
                    gout0 += gx[1088] * gy[0] * gz[0];
                    gout1 += gx[960] * gy[64] * gz[64];
                    gout2 += gx[832] * gy[192] * gz[64];
                    gout3 += gx[896] * gy[0] * gz[192];
                    gout4 += gx[768] * gy[64] * gz[256];
                    gout5 += gx[640] * gy[384] * gz[64];
                    gout6 += gx[704] * gy[192] * gz[192];
                    gout7 += gx[576] * gy[256] * gz[256];
                    gout8 += gx[640] * gy[0] * gz[448];
                    gout9 += gx[512] * gy[576] * gz[0];
                    gout10 += gx[384] * gy[640] * gz[64];
                    gout11 += gx[256] * gy[768] * gz[64];
                    gout12 += gx[320] * gy[576] * gz[192];
                    gout13 += gx[192] * gy[640] * gz[256];
                    gout14 += gx[64] * gy[960] * gz[64];
                    gout15 += gx[128] * gy[768] * gz[192];
                    gout16 += gx[0] * gy[832] * gz[256];
                    gout17 += gx[64] * gy[576] * gz[448];
                    gout18 += gx[512] * gy[0] * gz[576];
                    gout19 += gx[384] * gy[64] * gz[640];
                    gout20 += gx[256] * gy[192] * gz[640];
                    gout21 += gx[320] * gy[0] * gz[768];
                    gout22 += gx[192] * gy[64] * gz[832];
                    gout23 += gx[64] * gy[384] * gz[640];
                    gout24 += gx[128] * gy[192] * gz[768];
                    gout25 += gx[0] * gy[256] * gz[832];
                    gout26 += gx[64] * gy[0] * gz[1024];
                    break;
                    case 1:
                    gout0 += gx[1024] * gy[64] * gz[0];
                    gout1 += gx[960] * gy[0] * gz[128];
                    gout2 += gx[768] * gy[320] * gz[0];
                    gout3 += gx[832] * gy[64] * gz[192];
                    gout4 += gx[768] * gy[0] * gz[320];
                    gout5 += gx[576] * gy[512] * gz[0];
                    gout6 += gx[640] * gy[256] * gz[192];
                    gout7 += gx[576] * gy[192] * gz[320];
                    gout8 += gx[576] * gy[128] * gz[384];
                    gout9 += gx[448] * gy[640] * gz[0];
                    gout10 += gx[384] * gy[576] * gz[128];
                    gout11 += gx[192] * gy[896] * gz[0];
                    gout12 += gx[256] * gy[640] * gz[192];
                    gout13 += gx[192] * gy[576] * gz[320];
                    gout14 += gx[0] * gy[1088] * gz[0];
                    gout15 += gx[64] * gy[832] * gz[192];
                    gout16 += gx[0] * gy[768] * gz[320];
                    gout17 += gx[0] * gy[704] * gz[384];
                    gout18 += gx[448] * gy[64] * gz[576];
                    gout19 += gx[384] * gy[0] * gz[704];
                    gout20 += gx[192] * gy[320] * gz[576];
                    gout21 += gx[256] * gy[64] * gz[768];
                    gout22 += gx[192] * gy[0] * gz[896];
                    gout23 += gx[0] * gy[512] * gz[576];
                    gout24 += gx[64] * gy[256] * gz[768];
                    gout25 += gx[0] * gy[192] * gz[896];
                    gout26 += gx[0] * gy[128] * gz[960];
                    break;
                    case 2:
                    gout0 += gx[1024] * gy[0] * gz[64];
                    gout1 += gx[896] * gy[192] * gz[0];
                    gout2 += gx[768] * gy[256] * gz[64];
                    gout3 += gx[832] * gy[0] * gz[256];
                    gout4 += gx[704] * gy[384] * gz[0];
                    gout5 += gx[576] * gy[448] * gz[64];
                    gout6 += gx[640] * gy[192] * gz[256];
                    gout7 += gx[704] * gy[0] * gz[384];
                    gout8 += gx[576] * gy[64] * gz[448];
                    gout9 += gx[448] * gy[576] * gz[64];
                    gout10 += gx[320] * gy[768] * gz[0];
                    gout11 += gx[192] * gy[832] * gz[64];
                    gout12 += gx[256] * gy[576] * gz[256];
                    gout13 += gx[128] * gy[960] * gz[0];
                    gout14 += gx[0] * gy[1024] * gz[64];
                    gout15 += gx[64] * gy[768] * gz[256];
                    gout16 += gx[128] * gy[576] * gz[384];
                    gout17 += gx[0] * gy[640] * gz[448];
                    gout18 += gx[448] * gy[0] * gz[640];
                    gout19 += gx[320] * gy[192] * gz[576];
                    gout20 += gx[192] * gy[256] * gz[640];
                    gout21 += gx[256] * gy[0] * gz[832];
                    gout22 += gx[128] * gy[384] * gz[576];
                    gout23 += gx[0] * gy[448] * gz[640];
                    gout24 += gx[64] * gy[192] * gz[832];
                    gout25 += gx[128] * gy[0] * gz[960];
                    gout26 += gx[0] * gy[64] * gz[1024];
                    break;
                    case 3:
                    gout0 += gx[960] * gy[128] * gz[0];
                    gout1 += gx[832] * gy[256] * gz[0];
                    gout2 += gx[768] * gy[192] * gz[128];
                    gout3 += gx[768] * gy[128] * gz[192];
                    gout4 += gx[640] * gy[448] * gz[0];
                    gout5 += gx[576] * gy[384] * gz[128];
                    gout6 += gx[576] * gy[320] * gz[192];
                    gout7 += gx[640] * gy[64] * gz[384];
                    gout8 += gx[576] * gy[0] * gz[512];
                    gout9 += gx[384] * gy[704] * gz[0];
                    gout10 += gx[256] * gy[832] * gz[0];
                    gout11 += gx[192] * gy[768] * gz[128];
                    gout12 += gx[192] * gy[704] * gz[192];
                    gout13 += gx[64] * gy[1024] * gz[0];
                    gout14 += gx[0] * gy[960] * gz[128];
                    gout15 += gx[0] * gy[896] * gz[192];
                    gout16 += gx[64] * gy[640] * gz[384];
                    gout17 += gx[0] * gy[576] * gz[512];
                    gout18 += gx[384] * gy[128] * gz[576];
                    gout19 += gx[256] * gy[256] * gz[576];
                    gout20 += gx[192] * gy[192] * gz[704];
                    gout21 += gx[192] * gy[128] * gz[768];
                    gout22 += gx[64] * gy[448] * gz[576];
                    gout23 += gx[0] * gy[384] * gz[704];
                    gout24 += gx[0] * gy[320] * gz[768];
                    gout25 += gx[64] * gy[64] * gz[960];
                    gout26 += gx[0] * gy[0] * gz[1088];
                    break;
                    }
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(l0+2)*nao+(k0+4)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+2)*nao+(k0+5)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout25) * dm[(l0+2)*nao+(k0+4)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+5)*nao+(l0+2), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(l0+2)*nao+(k0+4)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+2)*nao+(k0+5)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout25) * dm[(l0+2)*nao+(k0+4)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+5)*nao+(l0+2), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(l0+2)*nao+(k0+5)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(l0+2)*nao+(k0+4)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+2)*nao+(k0+5)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+2)];
                    atomicAdd(vj+(k0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+4)];
                    atomicAdd(vj+(k0+5)*nao+(l0+2), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(l0+2)*nao+(k0+5)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(l0+2)*nao+(k0+4)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+2)*nao+(k0+5)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+3)];
                    atomicAdd(vj+(k0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+5)];
                    atomicAdd(vj+(k0+5)*nao+(l0+2), val);
                    break;
                    }
                    vj += nao * nao;
                }
                if (do_k) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+5)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+4)];
                    atomicAdd(vk+(i0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+5)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    break;
                    }
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2021(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2021<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2100(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    const FloatType hrr_2100x = trr_30x - xjxi * trr_20x;
                    gout0 += hrr_2100x * fac * wt;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_1100x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_1100x * fac * trr_10z;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += hrr_0100x * trr_20y * wt;
                    gout4 += hrr_0100x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += hrr_0100x * fac * trr_20z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout6 += trr_20x * hrr_0100y * wt;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout7 += trr_10x * hrr_1100y * wt;
                    gout8 += trr_10x * hrr_0100y * trr_10z;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    const FloatType hrr_2100y = trr_30y - yjyi * trr_20y;
                    gout9 += 1 * hrr_2100y * wt;
                    gout10 += 1 * hrr_1100y * trr_10z;
                    gout11 += 1 * hrr_0100y * trr_20z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout12 += trr_20x * fac * hrr_0100z;
                    gout13 += trr_10x * trr_10y * hrr_0100z;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout14 += trr_10x * fac * hrr_1100z;
                    gout15 += 1 * trr_20y * hrr_0100z;
                    gout16 += 1 * trr_10y * hrr_1100z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    const FloatType hrr_2100z = trr_30z - zjzi * trr_20z;
                    gout17 += 1 * fac * hrr_2100z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_2100(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2100<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2110(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    FloatType gout36;
    FloatType gout37;
    FloatType gout38;
    FloatType gout39;
    FloatType gout40;
    FloatType gout41;
    FloatType gout42;
    FloatType gout43;
    FloatType gout44;
    FloatType gout45;
    FloatType gout46;
    FloatType gout47;
    FloatType gout48;
    FloatType gout49;
    FloatType gout50;
    FloatType gout51;
    FloatType gout52;
    FloatType gout53;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        gout36 = 0;
        gout37 = 0;
        gout38 = 0;
        gout39 = 0;
        gout40 = 0;
        gout41 = 0;
        gout42 = 0;
        gout43 = 0;
        gout44 = 0;
        gout45 = 0;
        gout46 = 0;
        gout47 = 0;
        gout48 = 0;
        gout49 = 0;
        gout50 = 0;
        gout51 = 0;
        gout52 = 0;
        gout53 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    const FloatType trr_31x = cpx * trr_30x + 3*b00 * trr_20x;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    const FloatType hrr_2110x = trr_31x - xjxi * trr_21x;
                    gout0 += hrr_2110x * fac * wt;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType hrr_1110x = trr_21x - xjxi * trr_11x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_1110x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_1110x * fac * trr_10z;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType hrr_0110x = trr_11x - xjxi * trr_01x;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += hrr_0110x * trr_20y * wt;
                    gout4 += hrr_0110x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += hrr_0110x * fac * trr_20z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout6 += trr_21x * hrr_0100y * wt;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout7 += trr_11x * hrr_1100y * wt;
                    gout8 += trr_11x * hrr_0100y * trr_10z;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    const FloatType hrr_2100y = trr_30y - yjyi * trr_20y;
                    gout9 += trr_01x * hrr_2100y * wt;
                    gout10 += trr_01x * hrr_1100y * trr_10z;
                    gout11 += trr_01x * hrr_0100y * trr_20z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout12 += trr_21x * fac * hrr_0100z;
                    gout13 += trr_11x * trr_10y * hrr_0100z;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout14 += trr_11x * fac * hrr_1100z;
                    gout15 += trr_01x * trr_20y * hrr_0100z;
                    gout16 += trr_01x * trr_10y * hrr_1100z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    const FloatType hrr_2100z = trr_30z - zjzi * trr_20z;
                    gout17 += trr_01x * fac * hrr_2100z;
                    const FloatType hrr_2100x = trr_30x - xjxi * trr_20x;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout18 += hrr_2100x * trr_01y * wt;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout19 += hrr_1100x * trr_11y * wt;
                    gout20 += hrr_1100x * trr_01y * trr_10z;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    gout21 += hrr_0100x * trr_21y * wt;
                    gout22 += hrr_0100x * trr_11y * trr_10z;
                    gout23 += hrr_0100x * trr_01y * trr_20z;
                    const FloatType hrr_0110y = trr_11y - yjyi * trr_01y;
                    gout24 += trr_20x * hrr_0110y * wt;
                    const FloatType hrr_1110y = trr_21y - yjyi * trr_11y;
                    gout25 += trr_10x * hrr_1110y * wt;
                    gout26 += trr_10x * hrr_0110y * trr_10z;
                    const FloatType trr_31y = cpy * trr_30y + 3*b00 * trr_20y;
                    const FloatType hrr_2110y = trr_31y - yjyi * trr_21y;
                    gout27 += 1 * hrr_2110y * wt;
                    gout28 += 1 * hrr_1110y * trr_10z;
                    gout29 += 1 * hrr_0110y * trr_20z;
                    gout30 += trr_20x * trr_01y * hrr_0100z;
                    gout31 += trr_10x * trr_11y * hrr_0100z;
                    gout32 += trr_10x * trr_01y * hrr_1100z;
                    gout33 += 1 * trr_21y * hrr_0100z;
                    gout34 += 1 * trr_11y * hrr_1100z;
                    gout35 += 1 * trr_01y * hrr_2100z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout36 += hrr_2100x * fac * trr_01z;
                    gout37 += hrr_1100x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout38 += hrr_1100x * fac * trr_11z;
                    gout39 += hrr_0100x * trr_20y * trr_01z;
                    gout40 += hrr_0100x * trr_10y * trr_11z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    gout41 += hrr_0100x * fac * trr_21z;
                    gout42 += trr_20x * hrr_0100y * trr_01z;
                    gout43 += trr_10x * hrr_1100y * trr_01z;
                    gout44 += trr_10x * hrr_0100y * trr_11z;
                    gout45 += 1 * hrr_2100y * trr_01z;
                    gout46 += 1 * hrr_1100y * trr_11z;
                    gout47 += 1 * hrr_0100y * trr_21z;
                    const FloatType hrr_0110z = trr_11z - zjzi * trr_01z;
                    gout48 += trr_20x * fac * hrr_0110z;
                    gout49 += trr_10x * trr_10y * hrr_0110z;
                    const FloatType hrr_1110z = trr_21z - zjzi * trr_11z;
                    gout50 += trr_10x * fac * hrr_1110z;
                    gout51 += 1 * trr_20y * hrr_0110z;
                    gout52 += 1 * trr_10y * hrr_1110z;
                    const FloatType trr_31z = cpz * trr_30z + 3*b00 * trr_20z;
                    const FloatType hrr_2110z = trr_31z - zjzi * trr_21z;
                    gout53 += 1 * fac * hrr_2110z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout36) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout42) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout30) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout37) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout43) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout31) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout38) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout44) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout32) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout39) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout45) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout33) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout40) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout46) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout34) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout41) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout47) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout35) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout27) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout42) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout44) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout45) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout46) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout47) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout48) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout49) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout50) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout51) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout52) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout53) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout42) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout43) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout44) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout45) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout46) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout47) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout39) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout40) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout41) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout42) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout43) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout44) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout45) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout46) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout47) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout48) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout49) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout50) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout51) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout52) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout53) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout42) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout48) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout49) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout44) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout50) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout45) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout51) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout46) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout52) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout47) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout53) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout41) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout42) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout43) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout44) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout45) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout46) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout47) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout48) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout49) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout50) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout51) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout52) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout53) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2110(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2110<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2111(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int gout_id = threadIdx.y;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *cicj_cache = (FloatType *)shared_memory;
    FloatType *rw = cicj_cache + iprim*jprim*TILE2 + sq_id;
    FloatType *gx = rw + nroots * 128;
    FloatType *gy = gx + 1536;
    FloatType *gz = gy + 1536;
    FloatType *rjri = gz + 1536;
    FloatType *rlrk = rjri + 192;
    FloatType *Rpq = rlrk + 192;

    int thread_id = 64 * gout_id + sq_id;
    int threads = 256;
    for (int n = thread_id; n < iprim*jprim*TILE2; n += threads) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        cicj_cache[sh_ij+ijp*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    FloatType gout36;
    FloatType gout37;
    FloatType gout38;
    FloatType gout39;
    FloatType gout40;
    FloatType s0, s1, s2;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += 64) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        if (gout_id == 0) {
            const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
            const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
            const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            rjri[0] = xjxi;
            rjri[64] = yjyi;
            rjri[128] = zjzi;
            rlrk[0] = xlxk;
            rlrk[64] = ylyk;
            rlrk[128] = zlzk;
        }
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        gout36 = 0;
        gout37 = 0;
        gout38 = 0;
        gout39 = 0;
        gout40 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            __syncthreads();
            if (gout_id == 0) {
                const FloatType xlxk = rlrk[0];
                const FloatType ylyk = rlrk[64];
                const FloatType zlzk = rlrk[128];
                const FloatType theta_kl = ak * al_akl;
                const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
                const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
                gx[0] = ckcl;
            }
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType aj_aij = aj / aij;
                const FloatType xij = static_cast<FloatType>(ri[0]) + rjri[0] * aj_aij;
                const FloatType yij = static_cast<FloatType>(ri[1]) + rjri[64] * aj_aij;
                const FloatType zij = static_cast<FloatType>(ri[2]) + rjri[128] * aj_aij;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + rlrk[0] * al_akl;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + rlrk[64] * al_akl;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + rlrk[128] * al_akl;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                __syncthreads();
                if (gout_id == 0) {
                    Rpq[0] = xpq;
                    Rpq[64] = ypq;
                    Rpq[128] = zpq;
                    const FloatType cicj = cicj_cache[sh_ij+ijp*TILE2];
                    gy[0] = cicj / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                }
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                __syncthreads();
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, 64, gout_id, 4);
                for (int irys = 0; irys < nroots; ++irys) {
                    __syncthreads();
                    const FloatType rt = rw[irys*128];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    for (int n = gout_id; n < 3; n += 4) {
                        if (n == 2) {
                            gz[0] = rw[irys*128+64];
                        }
                        FloatType *_gx = gx + n * 1536;
                        const FloatType xjxi = rjri[n*64];
                        const FloatType Rpa = xjxi * aj_aij;
                        const FloatType c0x = Rpa - rt_aij * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = c0x * s0;
                        _gx[64] = s1;
                        s2 = c0x * s1 + 1 * b10 * s0;
                        _gx[128] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = c0x * s1 + 2 * b10 * s0;
                        _gx[192] = s2;
                        const FloatType xlxk = rlrk[n*64];
                        const FloatType Rqc = xlxk * al_akl;
                        const FloatType cpx = Rqc + rt_akl * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = cpx * s0;
                        _gx[384] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        _gx[768] = s2;
                        s0 = _gx[64];
                        s1 = cpx * s0;
                        s1 += 1 * b00 * _gx[0];
                        _gx[448] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 1 * b00 * _gx[384];
                        _gx[832] = s2;
                        s0 = _gx[128];
                        s1 = cpx * s0;
                        s1 += 2 * b00 * _gx[64];
                        _gx[512] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 2 * b00 * _gx[448];
                        _gx[896] = s2;
                        s0 = _gx[192];
                        s1 = cpx * s0;
                        s1 += 3 * b00 * _gx[128];
                        _gx[576] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 3 * b00 * _gx[512];
                        _gx[960] = s2;
                        s1 = _gx[192];
                        s0 = _gx[128];
                        _gx[320] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[64];
                        _gx[256] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[0];
                        _gx[192] = s1 - xjxi * s0;
                        s1 = _gx[576];
                        s0 = _gx[512];
                        _gx[704] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[448];
                        _gx[640] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[384];
                        _gx[576] = s1 - xjxi * s0;
                        s1 = _gx[960];
                        s0 = _gx[896];
                        _gx[1088] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[832];
                        _gx[1024] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[768];
                        _gx[960] = s1 - xjxi * s0;
                        s1 = _gx[768];
                        s0 = _gx[384];
                        _gx[1152] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[0];
                        _gx[768] = s1 - xlxk * s0;
                        s1 = _gx[832];
                        s0 = _gx[448];
                        _gx[1216] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[64];
                        _gx[832] = s1 - xlxk * s0;
                        s1 = _gx[896];
                        s0 = _gx[512];
                        _gx[1280] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[128];
                        _gx[896] = s1 - xlxk * s0;
                        s1 = _gx[960];
                        s0 = _gx[576];
                        _gx[1344] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[192];
                        _gx[960] = s1 - xlxk * s0;
                        s1 = _gx[1024];
                        s0 = _gx[640];
                        _gx[1408] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[256];
                        _gx[1024] = s1 - xlxk * s0;
                        s1 = _gx[1088];
                        s0 = _gx[704];
                        _gx[1472] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[320];
                        _gx[1088] = s1 - xlxk * s0;
                    }
                    __syncthreads();
                    switch (gout_id) {
                    case 0:
                    gout0 += gx[1472] * gy[0] * gz[0];
                    gout1 += gx[1344] * gy[64] * gz[64];
                    gout2 += gx[1216] * gy[192] * gz[64];
                    gout3 += gx[1280] * gy[0] * gz[192];
                    gout4 += gx[1152] * gy[64] * gz[256];
                    gout5 += gx[1024] * gy[384] * gz[64];
                    gout6 += gx[896] * gy[576] * gz[0];
                    gout7 += gx[768] * gy[640] * gz[64];
                    gout8 += gx[832] * gy[384] * gz[256];
                    gout9 += gx[1088] * gy[0] * gz[384];
                    gout10 += gx[960] * gy[64] * gz[448];
                    gout11 += gx[832] * gy[192] * gz[448];
                    gout12 += gx[896] * gy[0] * gz[576];
                    gout13 += gx[768] * gy[64] * gz[640];
                    gout14 += gx[640] * gy[768] * gz[64];
                    gout15 += gx[512] * gy[960] * gz[0];
                    gout16 += gx[384] * gy[1024] * gz[64];
                    gout17 += gx[448] * gy[768] * gz[256];
                    gout18 += gx[320] * gy[1152] * gz[0];
                    gout19 += gx[192] * gy[1216] * gz[64];
                    gout20 += gx[64] * gy[1344] * gz[64];
                    gout21 += gx[128] * gy[1152] * gz[192];
                    gout22 += gx[0] * gy[1216] * gz[256];
                    gout23 += gx[256] * gy[768] * gz[448];
                    gout24 += gx[128] * gy[960] * gz[384];
                    gout25 += gx[0] * gy[1024] * gz[448];
                    gout26 += gx[64] * gy[768] * gz[640];
                    gout27 += gx[704] * gy[0] * gz[768];
                    gout28 += gx[576] * gy[64] * gz[832];
                    gout29 += gx[448] * gy[192] * gz[832];
                    gout30 += gx[512] * gy[0] * gz[960];
                    gout31 += gx[384] * gy[64] * gz[1024];
                    gout32 += gx[256] * gy[384] * gz[832];
                    gout33 += gx[128] * gy[576] * gz[768];
                    gout34 += gx[0] * gy[640] * gz[832];
                    gout35 += gx[64] * gy[384] * gz[1024];
                    gout36 += gx[320] * gy[0] * gz[1152];
                    gout37 += gx[192] * gy[64] * gz[1216];
                    gout38 += gx[64] * gy[192] * gz[1216];
                    gout39 += gx[128] * gy[0] * gz[1344];
                    gout40 += gx[0] * gy[64] * gz[1408];
                    break;
                    case 1:
                    gout0 += gx[1408] * gy[64] * gz[0];
                    gout1 += gx[1344] * gy[0] * gz[128];
                    gout2 += gx[1152] * gy[320] * gz[0];
                    gout3 += gx[1216] * gy[64] * gz[192];
                    gout4 += gx[1152] * gy[0] * gz[320];
                    gout5 += gx[960] * gy[512] * gz[0];
                    gout6 += gx[832] * gy[640] * gz[0];
                    gout7 += gx[768] * gy[576] * gz[128];
                    gout8 += gx[768] * gy[512] * gz[192];
                    gout9 += gx[1024] * gy[64] * gz[384];
                    gout10 += gx[960] * gy[0] * gz[512];
                    gout11 += gx[768] * gy[320] * gz[384];
                    gout12 += gx[832] * gy[64] * gz[576];
                    gout13 += gx[768] * gy[0] * gz[704];
                    gout14 += gx[576] * gy[896] * gz[0];
                    gout15 += gx[448] * gy[1024] * gz[0];
                    gout16 += gx[384] * gy[960] * gz[128];
                    gout17 += gx[384] * gy[896] * gz[192];
                    gout18 += gx[256] * gy[1216] * gz[0];
                    gout19 += gx[192] * gy[1152] * gz[128];
                    gout20 += gx[0] * gy[1472] * gz[0];
                    gout21 += gx[64] * gy[1216] * gz[192];
                    gout22 += gx[0] * gy[1152] * gz[320];
                    gout23 += gx[192] * gy[896] * gz[384];
                    gout24 += gx[64] * gy[1024] * gz[384];
                    gout25 += gx[0] * gy[960] * gz[512];
                    gout26 += gx[0] * gy[896] * gz[576];
                    gout27 += gx[640] * gy[64] * gz[768];
                    gout28 += gx[576] * gy[0] * gz[896];
                    gout29 += gx[384] * gy[320] * gz[768];
                    gout30 += gx[448] * gy[64] * gz[960];
                    gout31 += gx[384] * gy[0] * gz[1088];
                    gout32 += gx[192] * gy[512] * gz[768];
                    gout33 += gx[64] * gy[640] * gz[768];
                    gout34 += gx[0] * gy[576] * gz[896];
                    gout35 += gx[0] * gy[512] * gz[960];
                    gout36 += gx[256] * gy[64] * gz[1152];
                    gout37 += gx[192] * gy[0] * gz[1280];
                    gout38 += gx[0] * gy[320] * gz[1152];
                    gout39 += gx[64] * gy[64] * gz[1344];
                    gout40 += gx[0] * gy[0] * gz[1472];
                    break;
                    case 2:
                    gout0 += gx[1408] * gy[0] * gz[64];
                    gout1 += gx[1280] * gy[192] * gz[0];
                    gout2 += gx[1152] * gy[256] * gz[64];
                    gout3 += gx[1216] * gy[0] * gz[256];
                    gout4 += gx[1088] * gy[384] * gz[0];
                    gout5 += gx[960] * gy[448] * gz[64];
                    gout6 += gx[832] * gy[576] * gz[64];
                    gout7 += gx[896] * gy[384] * gz[192];
                    gout8 += gx[768] * gy[448] * gz[256];
                    gout9 += gx[1024] * gy[0] * gz[448];
                    gout10 += gx[896] * gy[192] * gz[384];
                    gout11 += gx[768] * gy[256] * gz[448];
                    gout12 += gx[832] * gy[0] * gz[640];
                    gout13 += gx[704] * gy[768] * gz[0];
                    gout14 += gx[576] * gy[832] * gz[64];
                    gout15 += gx[448] * gy[960] * gz[64];
                    gout16 += gx[512] * gy[768] * gz[192];
                    gout17 += gx[384] * gy[832] * gz[256];
                    gout18 += gx[256] * gy[1152] * gz[64];
                    gout19 += gx[128] * gy[1344] * gz[0];
                    gout20 += gx[0] * gy[1408] * gz[64];
                    gout21 += gx[64] * gy[1152] * gz[256];
                    gout22 += gx[320] * gy[768] * gz[384];
                    gout23 += gx[192] * gy[832] * gz[448];
                    gout24 += gx[64] * gy[960] * gz[448];
                    gout25 += gx[128] * gy[768] * gz[576];
                    gout26 += gx[0] * gy[832] * gz[640];
                    gout27 += gx[640] * gy[0] * gz[832];
                    gout28 += gx[512] * gy[192] * gz[768];
                    gout29 += gx[384] * gy[256] * gz[832];
                    gout30 += gx[448] * gy[0] * gz[1024];
                    gout31 += gx[320] * gy[384] * gz[768];
                    gout32 += gx[192] * gy[448] * gz[832];
                    gout33 += gx[64] * gy[576] * gz[832];
                    gout34 += gx[128] * gy[384] * gz[960];
                    gout35 += gx[0] * gy[448] * gz[1024];
                    gout36 += gx[256] * gy[0] * gz[1216];
                    gout37 += gx[128] * gy[192] * gz[1152];
                    gout38 += gx[0] * gy[256] * gz[1216];
                    gout39 += gx[64] * gy[0] * gz[1408];
                    break;
                    case 3:
                    gout0 += gx[1344] * gy[128] * gz[0];
                    gout1 += gx[1216] * gy[256] * gz[0];
                    gout2 += gx[1152] * gy[192] * gz[128];
                    gout3 += gx[1152] * gy[128] * gz[192];
                    gout4 += gx[1024] * gy[448] * gz[0];
                    gout5 += gx[960] * gy[384] * gz[128];
                    gout6 += gx[768] * gy[704] * gz[0];
                    gout7 += gx[832] * gy[448] * gz[192];
                    gout8 += gx[768] * gy[384] * gz[320];
                    gout9 += gx[960] * gy[128] * gz[384];
                    gout10 += gx[832] * gy[256] * gz[384];
                    gout11 += gx[768] * gy[192] * gz[512];
                    gout12 += gx[768] * gy[128] * gz[576];
                    gout13 += gx[640] * gy[832] * gz[0];
                    gout14 += gx[576] * gy[768] * gz[128];
                    gout15 += gx[384] * gy[1088] * gz[0];
                    gout16 += gx[448] * gy[832] * gz[192];
                    gout17 += gx[384] * gy[768] * gz[320];
                    gout18 += gx[192] * gy[1280] * gz[0];
                    gout19 += gx[64] * gy[1408] * gz[0];
                    gout20 += gx[0] * gy[1344] * gz[128];
                    gout21 += gx[0] * gy[1280] * gz[192];
                    gout22 += gx[256] * gy[832] * gz[384];
                    gout23 += gx[192] * gy[768] * gz[512];
                    gout24 += gx[0] * gy[1088] * gz[384];
                    gout25 += gx[64] * gy[832] * gz[576];
                    gout26 += gx[0] * gy[768] * gz[704];
                    gout27 += gx[576] * gy[128] * gz[768];
                    gout28 += gx[448] * gy[256] * gz[768];
                    gout29 += gx[384] * gy[192] * gz[896];
                    gout30 += gx[384] * gy[128] * gz[960];
                    gout31 += gx[256] * gy[448] * gz[768];
                    gout32 += gx[192] * gy[384] * gz[896];
                    gout33 += gx[0] * gy[704] * gz[768];
                    gout34 += gx[64] * gy[448] * gz[960];
                    gout35 += gx[0] * gy[384] * gz[1088];
                    gout36 += gx[192] * gy[128] * gz[1152];
                    gout37 += gx[64] * gy[256] * gz[1152];
                    gout38 += gx[0] * gy[192] * gz[1280];
                    gout39 += gx[0] * gy[128] * gz[1344];
                    break;
                    }
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout34) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout40) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout37) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout37) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    }
                    vj += nao * nao;
                }
                if (do_k) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout33) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout33) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout31) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout34) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(i0+4)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+4)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(l0+1)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+5)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout34) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout30) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+2)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+1)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(l0+2)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(l0+1)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    }
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2111(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2111<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2120(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int gout_id = threadIdx.y;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *cicj_cache = (FloatType *)shared_memory;
    FloatType *rw = cicj_cache + iprim*jprim*TILE2 + sq_id;
    FloatType *gx = rw + nroots * 128;
    FloatType *gy = gx + 1152;
    FloatType *gz = gy + 1152;
    FloatType *rjri = gz + 1152;
    FloatType *rlrk = rjri + 192;
    FloatType *Rpq = rlrk + 192;

    int thread_id = 64 * gout_id + sq_id;
    int threads = 256;
    for (int n = thread_id; n < iprim*jprim*TILE2; n += threads) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        cicj_cache[sh_ij+ijp*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType s0, s1, s2;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += 64) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        if (gout_id == 0) {
            const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
            const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
            const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            rjri[0] = xjxi;
            rjri[64] = yjyi;
            rjri[128] = zjzi;
            rlrk[0] = xlxk;
            rlrk[64] = ylyk;
            rlrk[128] = zlzk;
        }
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            __syncthreads();
            if (gout_id == 0) {
                const FloatType xlxk = rlrk[0];
                const FloatType ylyk = rlrk[64];
                const FloatType zlzk = rlrk[128];
                const FloatType theta_kl = ak * al_akl;
                const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
                const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
                gx[0] = ckcl;
            }
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType aj_aij = aj / aij;
                const FloatType xij = static_cast<FloatType>(ri[0]) + rjri[0] * aj_aij;
                const FloatType yij = static_cast<FloatType>(ri[1]) + rjri[64] * aj_aij;
                const FloatType zij = static_cast<FloatType>(ri[2]) + rjri[128] * aj_aij;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + rlrk[0] * al_akl;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + rlrk[64] * al_akl;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + rlrk[128] * al_akl;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                __syncthreads();
                if (gout_id == 0) {
                    Rpq[0] = xpq;
                    Rpq[64] = ypq;
                    Rpq[128] = zpq;
                    const FloatType cicj = cicj_cache[sh_ij+ijp*TILE2];
                    gy[0] = cicj / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                }
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                __syncthreads();
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, 64, gout_id, 4);
                for (int irys = 0; irys < nroots; ++irys) {
                    __syncthreads();
                    const FloatType rt = rw[irys*128];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    for (int n = gout_id; n < 3; n += 4) {
                        if (n == 2) {
                            gz[0] = rw[irys*128+64];
                        }
                        FloatType *_gx = gx + n * 1152;
                        const FloatType xjxi = rjri[n*64];
                        const FloatType Rpa = xjxi * aj_aij;
                        const FloatType c0x = Rpa - rt_aij * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = c0x * s0;
                        _gx[64] = s1;
                        s2 = c0x * s1 + 1 * b10 * s0;
                        _gx[128] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = c0x * s1 + 2 * b10 * s0;
                        _gx[192] = s2;
                        const FloatType xlxk = rlrk[n*64];
                        const FloatType Rqc = xlxk * al_akl;
                        const FloatType cpx = Rqc + rt_akl * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = cpx * s0;
                        _gx[384] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        _gx[768] = s2;
                        s0 = _gx[64];
                        s1 = cpx * s0;
                        s1 += 1 * b00 * _gx[0];
                        _gx[448] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 1 * b00 * _gx[384];
                        _gx[832] = s2;
                        s0 = _gx[128];
                        s1 = cpx * s0;
                        s1 += 2 * b00 * _gx[64];
                        _gx[512] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 2 * b00 * _gx[448];
                        _gx[896] = s2;
                        s0 = _gx[192];
                        s1 = cpx * s0;
                        s1 += 3 * b00 * _gx[128];
                        _gx[576] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 3 * b00 * _gx[512];
                        _gx[960] = s2;
                        s1 = _gx[192];
                        s0 = _gx[128];
                        _gx[320] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[64];
                        _gx[256] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[0];
                        _gx[192] = s1 - xjxi * s0;
                        s1 = _gx[576];
                        s0 = _gx[512];
                        _gx[704] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[448];
                        _gx[640] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[384];
                        _gx[576] = s1 - xjxi * s0;
                        s1 = _gx[960];
                        s0 = _gx[896];
                        _gx[1088] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[832];
                        _gx[1024] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[768];
                        _gx[960] = s1 - xjxi * s0;
                    }
                    __syncthreads();
                    switch (gout_id) {
                    case 0:
                    gout0 += gx[1088] * gy[0] * gz[0];
                    gout1 += gx[960] * gy[64] * gz[64];
                    gout2 += gx[832] * gy[192] * gz[64];
                    gout3 += gx[896] * gy[0] * gz[192];
                    gout4 += gx[768] * gy[64] * gz[256];
                    gout5 += gx[640] * gy[384] * gz[64];
                    gout6 += gx[512] * gy[576] * gz[0];
                    gout7 += gx[384] * gy[640] * gz[64];
                    gout8 += gx[448] * gy[384] * gz[256];
                    gout9 += gx[704] * gy[0] * gz[384];
                    gout10 += gx[576] * gy[64] * gz[448];
                    gout11 += gx[448] * gy[192] * gz[448];
                    gout12 += gx[512] * gy[0] * gz[576];
                    gout13 += gx[384] * gy[64] * gz[640];
                    gout14 += gx[256] * gy[768] * gz[64];
                    gout15 += gx[128] * gy[960] * gz[0];
                    gout16 += gx[0] * gy[1024] * gz[64];
                    gout17 += gx[64] * gy[768] * gz[256];
                    gout18 += gx[320] * gy[384] * gz[384];
                    gout19 += gx[192] * gy[448] * gz[448];
                    gout20 += gx[64] * gy[576] * gz[448];
                    gout21 += gx[128] * gy[384] * gz[576];
                    gout22 += gx[0] * gy[448] * gz[640];
                    gout23 += gx[256] * gy[0] * gz[832];
                    gout24 += gx[128] * gy[192] * gz[768];
                    gout25 += gx[0] * gy[256] * gz[832];
                    gout26 += gx[64] * gy[0] * gz[1024];
                    break;
                    case 1:
                    gout0 += gx[1024] * gy[64] * gz[0];
                    gout1 += gx[960] * gy[0] * gz[128];
                    gout2 += gx[768] * gy[320] * gz[0];
                    gout3 += gx[832] * gy[64] * gz[192];
                    gout4 += gx[768] * gy[0] * gz[320];
                    gout5 += gx[576] * gy[512] * gz[0];
                    gout6 += gx[448] * gy[640] * gz[0];
                    gout7 += gx[384] * gy[576] * gz[128];
                    gout8 += gx[384] * gy[512] * gz[192];
                    gout9 += gx[640] * gy[64] * gz[384];
                    gout10 += gx[576] * gy[0] * gz[512];
                    gout11 += gx[384] * gy[320] * gz[384];
                    gout12 += gx[448] * gy[64] * gz[576];
                    gout13 += gx[384] * gy[0] * gz[704];
                    gout14 += gx[192] * gy[896] * gz[0];
                    gout15 += gx[64] * gy[1024] * gz[0];
                    gout16 += gx[0] * gy[960] * gz[128];
                    gout17 += gx[0] * gy[896] * gz[192];
                    gout18 += gx[256] * gy[448] * gz[384];
                    gout19 += gx[192] * gy[384] * gz[512];
                    gout20 += gx[0] * gy[704] * gz[384];
                    gout21 += gx[64] * gy[448] * gz[576];
                    gout22 += gx[0] * gy[384] * gz[704];
                    gout23 += gx[192] * gy[128] * gz[768];
                    gout24 += gx[64] * gy[256] * gz[768];
                    gout25 += gx[0] * gy[192] * gz[896];
                    gout26 += gx[0] * gy[128] * gz[960];
                    break;
                    case 2:
                    gout0 += gx[1024] * gy[0] * gz[64];
                    gout1 += gx[896] * gy[192] * gz[0];
                    gout2 += gx[768] * gy[256] * gz[64];
                    gout3 += gx[832] * gy[0] * gz[256];
                    gout4 += gx[704] * gy[384] * gz[0];
                    gout5 += gx[576] * gy[448] * gz[64];
                    gout6 += gx[448] * gy[576] * gz[64];
                    gout7 += gx[512] * gy[384] * gz[192];
                    gout8 += gx[384] * gy[448] * gz[256];
                    gout9 += gx[640] * gy[0] * gz[448];
                    gout10 += gx[512] * gy[192] * gz[384];
                    gout11 += gx[384] * gy[256] * gz[448];
                    gout12 += gx[448] * gy[0] * gz[640];
                    gout13 += gx[320] * gy[768] * gz[0];
                    gout14 += gx[192] * gy[832] * gz[64];
                    gout15 += gx[64] * gy[960] * gz[64];
                    gout16 += gx[128] * gy[768] * gz[192];
                    gout17 += gx[0] * gy[832] * gz[256];
                    gout18 += gx[256] * gy[384] * gz[448];
                    gout19 += gx[128] * gy[576] * gz[384];
                    gout20 += gx[0] * gy[640] * gz[448];
                    gout21 += gx[64] * gy[384] * gz[640];
                    gout22 += gx[320] * gy[0] * gz[768];
                    gout23 += gx[192] * gy[64] * gz[832];
                    gout24 += gx[64] * gy[192] * gz[832];
                    gout25 += gx[128] * gy[0] * gz[960];
                    gout26 += gx[0] * gy[64] * gz[1024];
                    break;
                    case 3:
                    gout0 += gx[960] * gy[128] * gz[0];
                    gout1 += gx[832] * gy[256] * gz[0];
                    gout2 += gx[768] * gy[192] * gz[128];
                    gout3 += gx[768] * gy[128] * gz[192];
                    gout4 += gx[640] * gy[448] * gz[0];
                    gout5 += gx[576] * gy[384] * gz[128];
                    gout6 += gx[384] * gy[704] * gz[0];
                    gout7 += gx[448] * gy[448] * gz[192];
                    gout8 += gx[384] * gy[384] * gz[320];
                    gout9 += gx[576] * gy[128] * gz[384];
                    gout10 += gx[448] * gy[256] * gz[384];
                    gout11 += gx[384] * gy[192] * gz[512];
                    gout12 += gx[384] * gy[128] * gz[576];
                    gout13 += gx[256] * gy[832] * gz[0];
                    gout14 += gx[192] * gy[768] * gz[128];
                    gout15 += gx[0] * gy[1088] * gz[0];
                    gout16 += gx[64] * gy[832] * gz[192];
                    gout17 += gx[0] * gy[768] * gz[320];
                    gout18 += gx[192] * gy[512] * gz[384];
                    gout19 += gx[64] * gy[640] * gz[384];
                    gout20 += gx[0] * gy[576] * gz[512];
                    gout21 += gx[0] * gy[512] * gz[576];
                    gout22 += gx[256] * gy[64] * gz[768];
                    gout23 += gx[192] * gy[0] * gz[896];
                    gout24 += gx[0] * gy[320] * gz[768];
                    gout25 += gx[64] * gy[64] * gz[960];
                    gout26 += gx[0] * gy[0] * gz[1088];
                    break;
                    }
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+2)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+4)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+4)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+3)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+5)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    break;
                    }
                    vj += nao * nao;
                }
                if (do_k) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+4)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+5)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+4)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(k0+5)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+4)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+5), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+4)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+5)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+4)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(k0+4)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+5)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(k0+4)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+5), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+5)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+4)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+5)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(k0+4)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(k0+5)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+5), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+5)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+4)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+5)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(k0+4)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(k0+5)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+5), val);
                    break;
                    }
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2120(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2120<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2200(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    const FloatType trr_40x = c0x * trr_30x + 3*b10 * trr_20x;
                    const FloatType hrr_3100x = trr_40x - xjxi * trr_30x;
                    const FloatType hrr_2100x = trr_30x - xjxi * trr_20x;
                    const FloatType hrr_2200x = hrr_3100x - xjxi * hrr_2100x;
                    gout0 += hrr_2200x * fac * wt;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    const FloatType hrr_1200x = hrr_2100x - xjxi * hrr_1100x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_1200x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_1200x * fac * trr_10z;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType hrr_0200x = hrr_1100x - xjxi * hrr_0100x;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += hrr_0200x * trr_20y * wt;
                    gout4 += hrr_0200x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += hrr_0200x * fac * trr_20z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout6 += hrr_2100x * hrr_0100y * wt;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout7 += hrr_1100x * hrr_1100y * wt;
                    gout8 += hrr_1100x * hrr_0100y * trr_10z;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    const FloatType hrr_2100y = trr_30y - yjyi * trr_20y;
                    gout9 += hrr_0100x * hrr_2100y * wt;
                    gout10 += hrr_0100x * hrr_1100y * trr_10z;
                    gout11 += hrr_0100x * hrr_0100y * trr_20z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout12 += hrr_2100x * fac * hrr_0100z;
                    gout13 += hrr_1100x * trr_10y * hrr_0100z;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout14 += hrr_1100x * fac * hrr_1100z;
                    gout15 += hrr_0100x * trr_20y * hrr_0100z;
                    gout16 += hrr_0100x * trr_10y * hrr_1100z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    const FloatType hrr_2100z = trr_30z - zjzi * trr_20z;
                    gout17 += hrr_0100x * fac * hrr_2100z;
                    const FloatType hrr_0200y = hrr_1100y - yjyi * hrr_0100y;
                    gout18 += trr_20x * hrr_0200y * wt;
                    const FloatType hrr_1200y = hrr_2100y - yjyi * hrr_1100y;
                    gout19 += trr_10x * hrr_1200y * wt;
                    gout20 += trr_10x * hrr_0200y * trr_10z;
                    const FloatType trr_40y = c0y * trr_30y + 3*b10 * trr_20y;
                    const FloatType hrr_3100y = trr_40y - yjyi * trr_30y;
                    const FloatType hrr_2200y = hrr_3100y - yjyi * hrr_2100y;
                    gout21 += 1 * hrr_2200y * wt;
                    gout22 += 1 * hrr_1200y * trr_10z;
                    gout23 += 1 * hrr_0200y * trr_20z;
                    gout24 += trr_20x * hrr_0100y * hrr_0100z;
                    gout25 += trr_10x * hrr_1100y * hrr_0100z;
                    gout26 += trr_10x * hrr_0100y * hrr_1100z;
                    gout27 += 1 * hrr_2100y * hrr_0100z;
                    gout28 += 1 * hrr_1100y * hrr_1100z;
                    gout29 += 1 * hrr_0100y * hrr_2100z;
                    const FloatType hrr_0200z = hrr_1100z - zjzi * hrr_0100z;
                    gout30 += trr_20x * fac * hrr_0200z;
                    gout31 += trr_10x * trr_10y * hrr_0200z;
                    const FloatType hrr_1200z = hrr_2100z - zjzi * hrr_1100z;
                    gout32 += trr_10x * fac * hrr_1200z;
                    gout33 += 1 * trr_20y * hrr_0200z;
                    gout34 += 1 * trr_10y * hrr_1200z;
                    const FloatType trr_40z = c0z * trr_30z + 3*b10 * trr_20z;
                    const FloatType hrr_3100z = trr_40z - zjzi * trr_30z;
                    const FloatType hrr_2200z = hrr_3100z - zjzi * hrr_2100z;
                    gout35 += 1 * fac * hrr_2200z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout33) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout34) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout29) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout35) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout18) * dm[(j0+3)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+3)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+3)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+3)*nao+(i0+3)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(i0+4)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(i0+5)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+4)*nao+(i0+2)];
                    val += static_cast<double>(gout27) * dm[(j0+4)*nao+(i0+3)];
                    val += static_cast<double>(gout28) * dm[(j0+4)*nao+(i0+4)];
                    val += static_cast<double>(gout29) * dm[(j0+4)*nao+(i0+5)];
                    val += static_cast<double>(gout30) * dm[(j0+5)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+5)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+5)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+5)*nao+(i0+3)];
                    val += static_cast<double>(gout34) * dm[(j0+5)*nao+(i0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+5)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(k0+0)];
                    atomicAdd(vk+(j0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2200(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2200<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_2210(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int gout_id = threadIdx.y;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *cicj_cache = (FloatType *)shared_memory;
    FloatType *rw = cicj_cache + iprim*jprim*TILE2 + sq_id;
    FloatType *gx = rw + nroots * 128;
    FloatType *gy = gx + 1152;
    FloatType *gz = gy + 1152;
    FloatType *rjri = gz + 1152;
    FloatType *rlrk = rjri + 192;
    FloatType *Rpq = rlrk + 192;

    int thread_id = 64 * gout_id + sq_id;
    int threads = 256;
    for (int n = thread_id; n < iprim*jprim*TILE2; n += threads) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        cicj_cache[sh_ij+ijp*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType s0, s1, s2;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += 64) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        if (gout_id == 0) {
            const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
            const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
            const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            rjri[0] = xjxi;
            rjri[64] = yjyi;
            rjri[128] = zjzi;
            rlrk[0] = xlxk;
            rlrk[64] = ylyk;
            rlrk[128] = zlzk;
        }
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            __syncthreads();
            if (gout_id == 0) {
                const FloatType xlxk = rlrk[0];
                const FloatType ylyk = rlrk[64];
                const FloatType zlzk = rlrk[128];
                const FloatType theta_kl = ak * al_akl;
                const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
                const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
                gx[0] = ckcl;
            }
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType aj_aij = aj / aij;
                const FloatType xij = static_cast<FloatType>(ri[0]) + rjri[0] * aj_aij;
                const FloatType yij = static_cast<FloatType>(ri[1]) + rjri[64] * aj_aij;
                const FloatType zij = static_cast<FloatType>(ri[2]) + rjri[128] * aj_aij;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + rlrk[0] * al_akl;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + rlrk[64] * al_akl;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + rlrk[128] * al_akl;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                __syncthreads();
                if (gout_id == 0) {
                    Rpq[0] = xpq;
                    Rpq[64] = ypq;
                    Rpq[128] = zpq;
                    const FloatType cicj = cicj_cache[sh_ij+ijp*TILE2];
                    gy[0] = cicj / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                }
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                __syncthreads();
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, 64, gout_id, 4);
                for (int irys = 0; irys < nroots; ++irys) {
                    __syncthreads();
                    const FloatType rt = rw[irys*128];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    for (int n = gout_id; n < 3; n += 4) {
                        if (n == 2) {
                            gz[0] = rw[irys*128+64];
                        }
                        FloatType *_gx = gx + n * 1152;
                        const FloatType xjxi = rjri[n*64];
                        const FloatType Rpa = xjxi * aj_aij;
                        const FloatType c0x = Rpa - rt_aij * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = c0x * s0;
                        _gx[64] = s1;
                        s2 = c0x * s1 + 1 * b10 * s0;
                        _gx[128] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = c0x * s1 + 2 * b10 * s0;
                        _gx[192] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = c0x * s1 + 3 * b10 * s0;
                        _gx[256] = s2;
                        const FloatType xlxk = rlrk[n*64];
                        const FloatType Rqc = xlxk * al_akl;
                        const FloatType cpx = Rqc + rt_akl * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = cpx * s0;
                        _gx[576] = s1;
                        s0 = _gx[64];
                        s1 = cpx * s0;
                        s1 += 1 * b00 * _gx[0];
                        _gx[640] = s1;
                        s0 = _gx[128];
                        s1 = cpx * s0;
                        s1 += 2 * b00 * _gx[64];
                        _gx[704] = s1;
                        s0 = _gx[192];
                        s1 = cpx * s0;
                        s1 += 3 * b00 * _gx[128];
                        _gx[768] = s1;
                        s0 = _gx[256];
                        s1 = cpx * s0;
                        s1 += 4 * b00 * _gx[192];
                        _gx[832] = s1;
                        s1 = _gx[256];
                        s0 = _gx[192];
                        _gx[384] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[128];
                        _gx[320] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[64];
                        _gx[256] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[0];
                        _gx[192] = s1 - xjxi * s0;
                        s1 = _gx[384];
                        s0 = _gx[320];
                        _gx[512] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[256];
                        _gx[448] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[192];
                        _gx[384] = s1 - xjxi * s0;
                        s1 = _gx[832];
                        s0 = _gx[768];
                        _gx[960] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[704];
                        _gx[896] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[640];
                        _gx[832] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[576];
                        _gx[768] = s1 - xjxi * s0;
                        s1 = _gx[960];
                        s0 = _gx[896];
                        _gx[1088] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[832];
                        _gx[1024] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[768];
                        _gx[960] = s1 - xjxi * s0;
                    }
                    __syncthreads();
                    switch (gout_id) {
                    case 0:
                    gout0 += gx[1088] * gy[0] * gz[0];
                    gout1 += gx[960] * gy[64] * gz[64];
                    gout2 += gx[832] * gy[192] * gz[64];
                    gout3 += gx[896] * gy[0] * gz[192];
                    gout4 += gx[768] * gy[64] * gz[256];
                    gout5 += gx[640] * gy[384] * gz[64];
                    gout6 += gx[704] * gy[192] * gz[192];
                    gout7 += gx[576] * gy[256] * gz[256];
                    gout8 += gx[640] * gy[0] * gz[448];
                    gout9 += gx[512] * gy[576] * gz[0];
                    gout10 += gx[384] * gy[640] * gz[64];
                    gout11 += gx[256] * gy[768] * gz[64];
                    gout12 += gx[320] * gy[576] * gz[192];
                    gout13 += gx[192] * gy[640] * gz[256];
                    gout14 += gx[64] * gy[960] * gz[64];
                    gout15 += gx[128] * gy[768] * gz[192];
                    gout16 += gx[0] * gy[832] * gz[256];
                    gout17 += gx[64] * gy[576] * gz[448];
                    gout18 += gx[512] * gy[0] * gz[576];
                    gout19 += gx[384] * gy[64] * gz[640];
                    gout20 += gx[256] * gy[192] * gz[640];
                    gout21 += gx[320] * gy[0] * gz[768];
                    gout22 += gx[192] * gy[64] * gz[832];
                    gout23 += gx[64] * gy[384] * gz[640];
                    gout24 += gx[128] * gy[192] * gz[768];
                    gout25 += gx[0] * gy[256] * gz[832];
                    gout26 += gx[64] * gy[0] * gz[1024];
                    break;
                    case 1:
                    gout0 += gx[1024] * gy[64] * gz[0];
                    gout1 += gx[960] * gy[0] * gz[128];
                    gout2 += gx[768] * gy[320] * gz[0];
                    gout3 += gx[832] * gy[64] * gz[192];
                    gout4 += gx[768] * gy[0] * gz[320];
                    gout5 += gx[576] * gy[512] * gz[0];
                    gout6 += gx[640] * gy[256] * gz[192];
                    gout7 += gx[576] * gy[192] * gz[320];
                    gout8 += gx[576] * gy[128] * gz[384];
                    gout9 += gx[448] * gy[640] * gz[0];
                    gout10 += gx[384] * gy[576] * gz[128];
                    gout11 += gx[192] * gy[896] * gz[0];
                    gout12 += gx[256] * gy[640] * gz[192];
                    gout13 += gx[192] * gy[576] * gz[320];
                    gout14 += gx[0] * gy[1088] * gz[0];
                    gout15 += gx[64] * gy[832] * gz[192];
                    gout16 += gx[0] * gy[768] * gz[320];
                    gout17 += gx[0] * gy[704] * gz[384];
                    gout18 += gx[448] * gy[64] * gz[576];
                    gout19 += gx[384] * gy[0] * gz[704];
                    gout20 += gx[192] * gy[320] * gz[576];
                    gout21 += gx[256] * gy[64] * gz[768];
                    gout22 += gx[192] * gy[0] * gz[896];
                    gout23 += gx[0] * gy[512] * gz[576];
                    gout24 += gx[64] * gy[256] * gz[768];
                    gout25 += gx[0] * gy[192] * gz[896];
                    gout26 += gx[0] * gy[128] * gz[960];
                    break;
                    case 2:
                    gout0 += gx[1024] * gy[0] * gz[64];
                    gout1 += gx[896] * gy[192] * gz[0];
                    gout2 += gx[768] * gy[256] * gz[64];
                    gout3 += gx[832] * gy[0] * gz[256];
                    gout4 += gx[704] * gy[384] * gz[0];
                    gout5 += gx[576] * gy[448] * gz[64];
                    gout6 += gx[640] * gy[192] * gz[256];
                    gout7 += gx[704] * gy[0] * gz[384];
                    gout8 += gx[576] * gy[64] * gz[448];
                    gout9 += gx[448] * gy[576] * gz[64];
                    gout10 += gx[320] * gy[768] * gz[0];
                    gout11 += gx[192] * gy[832] * gz[64];
                    gout12 += gx[256] * gy[576] * gz[256];
                    gout13 += gx[128] * gy[960] * gz[0];
                    gout14 += gx[0] * gy[1024] * gz[64];
                    gout15 += gx[64] * gy[768] * gz[256];
                    gout16 += gx[128] * gy[576] * gz[384];
                    gout17 += gx[0] * gy[640] * gz[448];
                    gout18 += gx[448] * gy[0] * gz[640];
                    gout19 += gx[320] * gy[192] * gz[576];
                    gout20 += gx[192] * gy[256] * gz[640];
                    gout21 += gx[256] * gy[0] * gz[832];
                    gout22 += gx[128] * gy[384] * gz[576];
                    gout23 += gx[0] * gy[448] * gz[640];
                    gout24 += gx[64] * gy[192] * gz[832];
                    gout25 += gx[128] * gy[0] * gz[960];
                    gout26 += gx[0] * gy[64] * gz[1024];
                    break;
                    case 3:
                    gout0 += gx[960] * gy[128] * gz[0];
                    gout1 += gx[832] * gy[256] * gz[0];
                    gout2 += gx[768] * gy[192] * gz[128];
                    gout3 += gx[768] * gy[128] * gz[192];
                    gout4 += gx[640] * gy[448] * gz[0];
                    gout5 += gx[576] * gy[384] * gz[128];
                    gout6 += gx[576] * gy[320] * gz[192];
                    gout7 += gx[640] * gy[64] * gz[384];
                    gout8 += gx[576] * gy[0] * gz[512];
                    gout9 += gx[384] * gy[704] * gz[0];
                    gout10 += gx[256] * gy[832] * gz[0];
                    gout11 += gx[192] * gy[768] * gz[128];
                    gout12 += gx[192] * gy[704] * gz[192];
                    gout13 += gx[64] * gy[1024] * gz[0];
                    gout14 += gx[0] * gy[960] * gz[128];
                    gout15 += gx[0] * gy[896] * gz[192];
                    gout16 += gx[64] * gy[640] * gz[384];
                    gout17 += gx[0] * gy[576] * gz[512];
                    gout18 += gx[384] * gy[128] * gz[576];
                    gout19 += gx[256] * gy[256] * gz[576];
                    gout20 += gx[192] * gy[192] * gz[704];
                    gout21 += gx[192] * gy[128] * gz[768];
                    gout22 += gx[64] * gy[448] * gz[576];
                    gout23 += gx[0] * gy[384] * gz[704];
                    gout24 += gx[0] * gy[320] * gz[768];
                    gout25 += gx[64] * gy[64] * gz[960];
                    gout26 += gx[0] * gy[0] * gz[1088];
                    break;
                    }
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(i0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+4)*nao+(i0+4)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(i0+2)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(i0+2)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+4)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(i0+2)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(i0+2)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(i0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(i0+4)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(i0+2)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(i0+3)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(i0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+4)*nao+(i0+5)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(i0+3)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(i0+3)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(i0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+4)*nao+(i0+5)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(i0+3)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(i0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(i0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(i0+5)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(i0+3)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+3)*nao+(i0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(i0+4)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(i0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+5)*nao+(i0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(i0+4)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+3)*nao+(i0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(i0+4)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(i0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+5)*nao+(i0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(i0+4)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(i0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(i0+4)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(i0+2)];
                    val += static_cast<double>(gout25) * dm[(j0+5)*nao+(i0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(i0+4)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+3)*nao+(i0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(i0+3)];
                    val += static_cast<double>(gout7) * dm[(j0+5)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(i0+5)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout13) * dm[(j0+3)*nao+(i0+1)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(i0+5)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+5)*nao+(i0+1)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(i0+5)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(i0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(i0+5)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(i0+3)];
                    val += static_cast<double>(gout25) * dm[(j0+5)*nao+(i0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(i0+5)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    }
                    vj += nao * nao;
                }
                if (do_k) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+2), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+2)];
                    atomicAdd(vk+(j0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(k0+2)];
                    atomicAdd(vk+(j0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+2), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+5)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(k0+2)];
                    atomicAdd(vk+(j0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(k0+2)];
                    atomicAdd(vk+(j0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+2)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+4)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+2), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(j0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+5)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(k0+2)];
                    atomicAdd(vk+(j0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(k0+2)];
                    atomicAdd(vk+(j0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+4)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(i0+3)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+5)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+2), val);
                    break;
                    }
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_2210(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_2210<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_3000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 2;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    gout0 += trr_30x * fac * wt;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += trr_20x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += trr_20x * fac * trr_10z;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += trr_10x * trr_20y * wt;
                    gout4 += trr_10x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += trr_10x * fac * trr_20z;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    gout6 += 1 * trr_30y * wt;
                    gout7 += 1 * trr_20y * trr_10z;
                    gout8 += 1 * trr_10y * trr_20z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    gout9 += 1 * fac * trr_30z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
#if CUDA_VERSION >= 12040
__global__ __maxnreg__(128)
#else
__global__
#endif
static void rys_jk_3000(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_3000<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_3010(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    const FloatType trr_31x = cpx * trr_30x + 3*b00 * trr_20x;
                    gout0 += trr_31x * fac * wt;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += trr_21x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += trr_21x * fac * trr_10z;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += trr_11x * trr_20y * wt;
                    gout4 += trr_11x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += trr_11x * fac * trr_20z;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    gout6 += trr_01x * trr_30y * wt;
                    gout7 += trr_01x * trr_20y * trr_10z;
                    gout8 += trr_01x * trr_10y * trr_20z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    gout9 += trr_01x * fac * trr_30z;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout10 += trr_30x * trr_01y * wt;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout11 += trr_20x * trr_11y * wt;
                    gout12 += trr_20x * trr_01y * trr_10z;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    gout13 += trr_10x * trr_21y * wt;
                    gout14 += trr_10x * trr_11y * trr_10z;
                    gout15 += trr_10x * trr_01y * trr_20z;
                    const FloatType trr_31y = cpy * trr_30y + 3*b00 * trr_20y;
                    gout16 += 1 * trr_31y * wt;
                    gout17 += 1 * trr_21y * trr_10z;
                    gout18 += 1 * trr_11y * trr_20z;
                    gout19 += 1 * trr_01y * trr_30z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout20 += trr_30x * fac * trr_01z;
                    gout21 += trr_20x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout22 += trr_20x * fac * trr_11z;
                    gout23 += trr_10x * trr_20y * trr_01z;
                    gout24 += trr_10x * trr_10y * trr_11z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    gout25 += trr_10x * fac * trr_21z;
                    gout26 += 1 * trr_30y * trr_01z;
                    gout27 += 1 * trr_20y * trr_11z;
                    gout28 += 1 * trr_10y * trr_21z;
                    const FloatType trr_31z = cpz * trr_30z + 3*b00 * trr_20z;
                    gout29 += 1 * fac * trr_31z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_3010(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_3010<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_3011(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int gout_id = threadIdx.y;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *cicj_cache = (FloatType *)shared_memory;
    FloatType *rw = cicj_cache + iprim*jprim*TILE2 + sq_id;
    FloatType *gx = rw + nroots * 128;
    FloatType *gy = gx + 1024;
    FloatType *gz = gy + 1024;
    FloatType *rjri = gz + 1024;
    FloatType *rlrk = rjri + 192;
    FloatType *Rpq = rlrk + 192;

    int thread_id = 64 * gout_id + sq_id;
    int threads = 256;
    for (int n = thread_id; n < iprim*jprim*TILE2; n += threads) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        cicj_cache[sh_ij+ijp*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType s0, s1, s2;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += 64) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        if (gout_id == 0) {
            const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
            const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
            const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            rjri[0] = xjxi;
            rjri[64] = yjyi;
            rjri[128] = zjzi;
            rlrk[0] = xlxk;
            rlrk[64] = ylyk;
            rlrk[128] = zlzk;
        }
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            __syncthreads();
            if (gout_id == 0) {
                const FloatType xlxk = rlrk[0];
                const FloatType ylyk = rlrk[64];
                const FloatType zlzk = rlrk[128];
                const FloatType theta_kl = ak * al_akl;
                const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
                const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
                gx[0] = ckcl;
            }
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType aj_aij = aj / aij;
                const FloatType xij = static_cast<FloatType>(ri[0]) + rjri[0] * aj_aij;
                const FloatType yij = static_cast<FloatType>(ri[1]) + rjri[64] * aj_aij;
                const FloatType zij = static_cast<FloatType>(ri[2]) + rjri[128] * aj_aij;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + rlrk[0] * al_akl;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + rlrk[64] * al_akl;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + rlrk[128] * al_akl;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                __syncthreads();
                if (gout_id == 0) {
                    Rpq[0] = xpq;
                    Rpq[64] = ypq;
                    Rpq[128] = zpq;
                    const FloatType cicj = cicj_cache[sh_ij+ijp*TILE2];
                    gy[0] = cicj / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                }
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                __syncthreads();
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, 64, gout_id, 4);
                for (int irys = 0; irys < nroots; ++irys) {
                    __syncthreads();
                    const FloatType rt = rw[irys*128];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    for (int n = gout_id; n < 3; n += 4) {
                        if (n == 2) {
                            gz[0] = rw[irys*128+64];
                        }
                        FloatType *_gx = gx + n * 1024;
                        const FloatType xjxi = rjri[n*64];
                        const FloatType Rpa = xjxi * aj_aij;
                        const FloatType c0x = Rpa - rt_aij * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = c0x * s0;
                        _gx[64] = s1;
                        s2 = c0x * s1 + 1 * b10 * s0;
                        _gx[128] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = c0x * s1 + 2 * b10 * s0;
                        _gx[192] = s2;
                        const FloatType xlxk = rlrk[n*64];
                        const FloatType Rqc = xlxk * al_akl;
                        const FloatType cpx = Rqc + rt_akl * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = cpx * s0;
                        _gx[256] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        _gx[512] = s2;
                        s0 = _gx[64];
                        s1 = cpx * s0;
                        s1 += 1 * b00 * _gx[0];
                        _gx[320] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 1 * b00 * _gx[256];
                        _gx[576] = s2;
                        s0 = _gx[128];
                        s1 = cpx * s0;
                        s1 += 2 * b00 * _gx[64];
                        _gx[384] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 2 * b00 * _gx[320];
                        _gx[640] = s2;
                        s0 = _gx[192];
                        s1 = cpx * s0;
                        s1 += 3 * b00 * _gx[128];
                        _gx[448] = s1;
                        s2 = cpx*s1 + 1 * b01 *s0;
                        s2 += 3 * b00 * _gx[384];
                        _gx[704] = s2;
                        s1 = _gx[512];
                        s0 = _gx[256];
                        _gx[768] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[0];
                        _gx[512] = s1 - xlxk * s0;
                        s1 = _gx[576];
                        s0 = _gx[320];
                        _gx[832] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[64];
                        _gx[576] = s1 - xlxk * s0;
                        s1 = _gx[640];
                        s0 = _gx[384];
                        _gx[896] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[128];
                        _gx[640] = s1 - xlxk * s0;
                        s1 = _gx[704];
                        s0 = _gx[448];
                        _gx[960] = s1 - xlxk * s0;
                        s1 = s0;
                        s0 = _gx[192];
                        _gx[704] = s1 - xlxk * s0;
                    }
                    __syncthreads();
                    switch (gout_id) {
                    case 0:
                    gout0 += gx[960] * gy[0] * gz[0];
                    gout1 += gx[832] * gy[64] * gz[64];
                    gout2 += gx[768] * gy[64] * gz[128];
                    gout3 += gx[640] * gy[256] * gz[64];
                    gout4 += gx[512] * gy[448] * gz[0];
                    gout5 += gx[704] * gy[0] * gz[256];
                    gout6 += gx[576] * gy[64] * gz[320];
                    gout7 += gx[512] * gy[64] * gz[384];
                    gout8 += gx[384] * gy[512] * gz[64];
                    gout9 += gx[256] * gy[704] * gz[0];
                    gout10 += gx[192] * gy[768] * gz[0];
                    gout11 += gx[64] * gy[832] * gz[64];
                    gout12 += gx[0] * gy[832] * gz[128];
                    gout13 += gx[128] * gy[512] * gz[320];
                    gout14 += gx[0] * gy[704] * gz[256];
                    gout15 += gx[448] * gy[0] * gz[512];
                    gout16 += gx[320] * gy[64] * gz[576];
                    gout17 += gx[256] * gy[64] * gz[640];
                    gout18 += gx[128] * gy[256] * gz[576];
                    gout19 += gx[0] * gy[448] * gz[512];
                    gout20 += gx[192] * gy[0] * gz[768];
                    gout21 += gx[64] * gy[64] * gz[832];
                    gout22 += gx[0] * gy[64] * gz[896];
                    break;
                    case 1:
                    gout0 += gx[896] * gy[64] * gz[0];
                    gout1 += gx[832] * gy[0] * gz[128];
                    gout2 += gx[768] * gy[0] * gz[192];
                    gout3 += gx[576] * gy[384] * gz[0];
                    gout4 += gx[512] * gy[384] * gz[64];
                    gout5 += gx[640] * gy[64] * gz[256];
                    gout6 += gx[576] * gy[0] * gz[384];
                    gout7 += gx[512] * gy[0] * gz[448];
                    gout8 += gx[320] * gy[640] * gz[0];
                    gout9 += gx[256] * gy[640] * gz[64];
                    gout10 += gx[128] * gy[832] * gz[0];
                    gout11 += gx[64] * gy[768] * gz[128];
                    gout12 += gx[0] * gy[768] * gz[192];
                    gout13 += gx[64] * gy[640] * gz[256];
                    gout14 += gx[0] * gy[640] * gz[320];
                    gout15 += gx[384] * gy[64] * gz[512];
                    gout16 += gx[320] * gy[0] * gz[640];
                    gout17 += gx[256] * gy[0] * gz[704];
                    gout18 += gx[64] * gy[384] * gz[512];
                    gout19 += gx[0] * gy[384] * gz[576];
                    gout20 += gx[128] * gy[64] * gz[768];
                    gout21 += gx[64] * gy[0] * gz[896];
                    gout22 += gx[0] * gy[0] * gz[960];
                    break;
                    case 2:
                    gout0 += gx[896] * gy[0] * gz[64];
                    gout1 += gx[768] * gy[192] * gz[0];
                    gout2 += gx[704] * gy[256] * gz[0];
                    gout3 += gx[576] * gy[320] * gz[64];
                    gout4 += gx[512] * gy[320] * gz[128];
                    gout5 += gx[640] * gy[0] * gz[320];
                    gout6 += gx[512] * gy[192] * gz[256];
                    gout7 += gx[448] * gy[512] * gz[0];
                    gout8 += gx[320] * gy[576] * gz[64];
                    gout9 += gx[256] * gy[576] * gz[128];
                    gout10 += gx[128] * gy[768] * gz[64];
                    gout11 += gx[0] * gy[960] * gz[0];
                    gout12 += gx[192] * gy[512] * gz[256];
                    gout13 += gx[64] * gy[576] * gz[320];
                    gout14 += gx[0] * gy[576] * gz[384];
                    gout15 += gx[384] * gy[0] * gz[576];
                    gout16 += gx[256] * gy[192] * gz[512];
                    gout17 += gx[192] * gy[256] * gz[512];
                    gout18 += gx[64] * gy[320] * gz[576];
                    gout19 += gx[0] * gy[320] * gz[640];
                    gout20 += gx[128] * gy[0] * gz[832];
                    gout21 += gx[0] * gy[192] * gz[768];
                    break;
                    case 3:
                    gout0 += gx[832] * gy[128] * gz[0];
                    gout1 += gx[768] * gy[128] * gz[64];
                    gout2 += gx[640] * gy[320] * gz[0];
                    gout3 += gx[576] * gy[256] * gz[128];
                    gout4 += gx[512] * gy[256] * gz[192];
                    gout5 += gx[576] * gy[128] * gz[256];
                    gout6 += gx[512] * gy[128] * gz[320];
                    gout7 += gx[384] * gy[576] * gz[0];
                    gout8 += gx[320] * gy[512] * gz[128];
                    gout9 += gx[256] * gy[512] * gz[192];
                    gout10 += gx[64] * gy[896] * gz[0];
                    gout11 += gx[0] * gy[896] * gz[64];
                    gout12 += gx[128] * gy[576] * gz[256];
                    gout13 += gx[64] * gy[512] * gz[384];
                    gout14 += gx[0] * gy[512] * gz[448];
                    gout15 += gx[320] * gy[128] * gz[512];
                    gout16 += gx[256] * gy[128] * gz[576];
                    gout17 += gx[128] * gy[320] * gz[512];
                    gout18 += gx[64] * gy[256] * gz[640];
                    gout19 += gx[0] * gy[256] * gz[704];
                    gout20 += gx[64] * gy[128] * gz[768];
                    gout21 += gx[0] * gy[128] * gz[832];
                    break;
                    }
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout17) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+8)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+6)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout17) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(l0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(l0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+2)*nao+(k0+2)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(l0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(l0+2)*nao+(k0+1)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+7)];
                    atomicAdd(vj+(k0+2)*nao+(l0+2), val);
                    break;
                    }
                    vj += nao * nao;
                }
                if (do_k) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+6)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+6)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+8)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+8)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+8)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(i0+8)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+8)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+6)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+6)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+8)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+8)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+6)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+8)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+6)*nao+(l0+2)];
                    val += static_cast<double>(gout12) * dm[(i0+8)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+4)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+6)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+8)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+7)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+7)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+9)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+9)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+9)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(i0+9)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout17) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+9)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+7)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+7)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+9)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+9)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(l0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+7)*nao+(l0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+9)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+9)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+7)*nao+(l0+2)];
                    val += static_cast<double>(gout12) * dm[(i0+9)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+5)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+7)*nao+(l0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+9)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+9)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+2)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+4)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+6)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+6)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+8)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+8)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+8)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+8)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+8)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+6)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+6)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+8)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+8)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(l0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+8)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+0)*nao+(l0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+2)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+4)*nao+(l0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+6)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+8)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+6)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+8)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+1)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+3)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+5)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+7)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+7)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+2)];
                    atomicAdd(vk+(i0+9)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    atomicAdd(vk+(i0+9)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout3) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout4) * dm[(i0+9)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+9)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout18) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout16) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+7)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+7)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+2)];
                    atomicAdd(vk+(i0+9)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+1)];
                    atomicAdd(vk+(i0+9)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+7)*nao+(l0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+1)*nao+(l0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+3)*nao+(l0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+5)*nao+(l0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+7)*nao+(l0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+9)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(l0+2)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(l0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(l0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(l0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+7)*nao+(l0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+9)*nao+(l0+1)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    break;
                    }
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_3011(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_3011<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_3020(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    FloatType gout36;
    FloatType gout37;
    FloatType gout38;
    FloatType gout39;
    FloatType gout40;
    FloatType gout41;
    FloatType gout42;
    FloatType gout43;
    FloatType gout44;
    FloatType gout45;
    FloatType gout46;
    FloatType gout47;
    FloatType gout48;
    FloatType gout49;
    FloatType gout50;
    FloatType gout51;
    FloatType gout52;
    FloatType gout53;
    FloatType gout54;
    FloatType gout55;
    FloatType gout56;
    FloatType gout57;
    FloatType gout58;
    FloatType gout59;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        gout36 = 0;
        gout37 = 0;
        gout38 = 0;
        gout39 = 0;
        gout40 = 0;
        gout41 = 0;
        gout42 = 0;
        gout43 = 0;
        gout44 = 0;
        gout45 = 0;
        gout46 = 0;
        gout47 = 0;
        gout48 = 0;
        gout49 = 0;
        gout50 = 0;
        gout51 = 0;
        gout52 = 0;
        gout53 = 0;
        gout54 = 0;
        gout55 = 0;
        gout56 = 0;
        gout57 = 0;
        gout58 = 0;
        gout59 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b01 = static_cast<FloatType>(0.5)/akl * (static_cast<FloatType>(1.0) - rt_akl);
                    const FloatType cpx = xqc + xpq*rt_akl;
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    const FloatType trr_31x = cpx * trr_30x + 3*b00 * trr_20x;
                    const FloatType trr_21x = cpx * trr_20x + 2*b00 * trr_10x;
                    const FloatType trr_32x = cpx * trr_31x + 1*b01 * trr_30x + 3*b00 * trr_21x;
                    gout0 += trr_32x * fac * wt;
                    const FloatType trr_11x = cpx * trr_10x + 1*b00 * 1;
                    const FloatType trr_22x = cpx * trr_21x + 1*b01 * trr_20x + 2*b00 * trr_11x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += trr_22x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += trr_22x * fac * trr_10z;
                    const FloatType trr_01x = cpx * 1;
                    const FloatType trr_12x = cpx * trr_11x + 1*b01 * trr_10x + 1*b00 * trr_01x;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += trr_12x * trr_20y * wt;
                    gout4 += trr_12x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += trr_12x * fac * trr_20z;
                    const FloatType trr_02x = cpx * trr_01x + 1*b01 * 1;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    gout6 += trr_02x * trr_30y * wt;
                    gout7 += trr_02x * trr_20y * trr_10z;
                    gout8 += trr_02x * trr_10y * trr_20z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    gout9 += trr_02x * fac * trr_30z;
                    const FloatType cpy = yqc + ypq*rt_akl;
                    const FloatType trr_01y = cpy * fac;
                    gout10 += trr_31x * trr_01y * wt;
                    const FloatType trr_11y = cpy * trr_10y + 1*b00 * fac;
                    gout11 += trr_21x * trr_11y * wt;
                    gout12 += trr_21x * trr_01y * trr_10z;
                    const FloatType trr_21y = cpy * trr_20y + 2*b00 * trr_10y;
                    gout13 += trr_11x * trr_21y * wt;
                    gout14 += trr_11x * trr_11y * trr_10z;
                    gout15 += trr_11x * trr_01y * trr_20z;
                    const FloatType trr_31y = cpy * trr_30y + 3*b00 * trr_20y;
                    gout16 += trr_01x * trr_31y * wt;
                    gout17 += trr_01x * trr_21y * trr_10z;
                    gout18 += trr_01x * trr_11y * trr_20z;
                    gout19 += trr_01x * trr_01y * trr_30z;
                    const FloatType cpz = zqc + zpq*rt_akl;
                    const FloatType trr_01z = cpz * wt;
                    gout20 += trr_31x * fac * trr_01z;
                    gout21 += trr_21x * trr_10y * trr_01z;
                    const FloatType trr_11z = cpz * trr_10z + 1*b00 * wt;
                    gout22 += trr_21x * fac * trr_11z;
                    gout23 += trr_11x * trr_20y * trr_01z;
                    gout24 += trr_11x * trr_10y * trr_11z;
                    const FloatType trr_21z = cpz * trr_20z + 2*b00 * trr_10z;
                    gout25 += trr_11x * fac * trr_21z;
                    gout26 += trr_01x * trr_30y * trr_01z;
                    gout27 += trr_01x * trr_20y * trr_11z;
                    gout28 += trr_01x * trr_10y * trr_21z;
                    const FloatType trr_31z = cpz * trr_30z + 3*b00 * trr_20z;
                    gout29 += trr_01x * fac * trr_31z;
                    const FloatType trr_02y = cpy * trr_01y + 1*b01 * fac;
                    gout30 += trr_30x * trr_02y * wt;
                    const FloatType trr_12y = cpy * trr_11y + 1*b01 * trr_10y + 1*b00 * trr_01y;
                    gout31 += trr_20x * trr_12y * wt;
                    gout32 += trr_20x * trr_02y * trr_10z;
                    const FloatType trr_22y = cpy * trr_21y + 1*b01 * trr_20y + 2*b00 * trr_11y;
                    gout33 += trr_10x * trr_22y * wt;
                    gout34 += trr_10x * trr_12y * trr_10z;
                    gout35 += trr_10x * trr_02y * trr_20z;
                    const FloatType trr_32y = cpy * trr_31y + 1*b01 * trr_30y + 3*b00 * trr_21y;
                    gout36 += 1 * trr_32y * wt;
                    gout37 += 1 * trr_22y * trr_10z;
                    gout38 += 1 * trr_12y * trr_20z;
                    gout39 += 1 * trr_02y * trr_30z;
                    gout40 += trr_30x * trr_01y * trr_01z;
                    gout41 += trr_20x * trr_11y * trr_01z;
                    gout42 += trr_20x * trr_01y * trr_11z;
                    gout43 += trr_10x * trr_21y * trr_01z;
                    gout44 += trr_10x * trr_11y * trr_11z;
                    gout45 += trr_10x * trr_01y * trr_21z;
                    gout46 += 1 * trr_31y * trr_01z;
                    gout47 += 1 * trr_21y * trr_11z;
                    gout48 += 1 * trr_11y * trr_21z;
                    gout49 += 1 * trr_01y * trr_31z;
                    const FloatType trr_02z = cpz * trr_01z + 1*b01 * wt;
                    gout50 += trr_30x * fac * trr_02z;
                    gout51 += trr_20x * trr_10y * trr_02z;
                    const FloatType trr_12z = cpz * trr_11z + 1*b01 * trr_10z + 1*b00 * trr_01z;
                    gout52 += trr_20x * fac * trr_12z;
                    gout53 += trr_10x * trr_20y * trr_02z;
                    gout54 += trr_10x * trr_10y * trr_12z;
                    const FloatType trr_22z = cpz * trr_21z + 1*b01 * trr_20z + 2*b00 * trr_11z;
                    gout55 += trr_10x * fac * trr_22z;
                    gout56 += 1 * trr_30y * trr_02z;
                    gout57 += 1 * trr_20y * trr_12z;
                    gout58 += 1 * trr_10y * trr_22z;
                    const FloatType trr_32z = cpz * trr_31z + 1*b01 * trr_30z + 3*b00 * trr_21z;
                    gout59 += 1 * fac * trr_32z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout30) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout40) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout50) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout41) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout51) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout42) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout52) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout43) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout53) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout44) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout54) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout45) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout55) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout36) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout46) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout56) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout37) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout47) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout57) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout38) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout48) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout58) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(l0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout39) * dm[(l0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout49) * dm[(l0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout59) * dm[(l0+0)*nao+(k0+5)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout42) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout43) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout44) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout48) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout49) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout50) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout51) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout52) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout53) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout54) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout55) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout56) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout57) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout58) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout59) * dm[(j0+0)*nao+(i0+9)];
                    atomicAdd(vj+(k0+5)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout50) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout51) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout42) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout52) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout43) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout53) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout44) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout54) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout55) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout56) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout57) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout48) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout58) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout49) * dm[(j0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout59) * dm[(j0+0)*nao+(k0+5)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+3)];
                    val += static_cast<double>(gout40) * dm[(i0+0)*nao+(k0+4)];
                    val += static_cast<double>(gout50) * dm[(i0+0)*nao+(k0+5)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+3)];
                    val += static_cast<double>(gout41) * dm[(i0+1)*nao+(k0+4)];
                    val += static_cast<double>(gout51) * dm[(i0+1)*nao+(k0+5)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+3)];
                    val += static_cast<double>(gout42) * dm[(i0+2)*nao+(k0+4)];
                    val += static_cast<double>(gout52) * dm[(i0+2)*nao+(k0+5)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(k0+3)];
                    val += static_cast<double>(gout43) * dm[(i0+3)*nao+(k0+4)];
                    val += static_cast<double>(gout53) * dm[(i0+3)*nao+(k0+5)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(k0+3)];
                    val += static_cast<double>(gout44) * dm[(i0+4)*nao+(k0+4)];
                    val += static_cast<double>(gout54) * dm[(i0+4)*nao+(k0+5)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(k0+3)];
                    val += static_cast<double>(gout45) * dm[(i0+5)*nao+(k0+4)];
                    val += static_cast<double>(gout55) * dm[(i0+5)*nao+(k0+5)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout36) * dm[(i0+6)*nao+(k0+3)];
                    val += static_cast<double>(gout46) * dm[(i0+6)*nao+(k0+4)];
                    val += static_cast<double>(gout56) * dm[(i0+6)*nao+(k0+5)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout37) * dm[(i0+7)*nao+(k0+3)];
                    val += static_cast<double>(gout47) * dm[(i0+7)*nao+(k0+4)];
                    val += static_cast<double>(gout57) * dm[(i0+7)*nao+(k0+5)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(k0+1)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(k0+2)];
                    val += static_cast<double>(gout38) * dm[(i0+8)*nao+(k0+3)];
                    val += static_cast<double>(gout48) * dm[(i0+8)*nao+(k0+4)];
                    val += static_cast<double>(gout58) * dm[(i0+8)*nao+(k0+5)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(k0+1)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(k0+2)];
                    val += static_cast<double>(gout39) * dm[(i0+9)*nao+(k0+3)];
                    val += static_cast<double>(gout49) * dm[(i0+9)*nao+(k0+4)];
                    val += static_cast<double>(gout59) * dm[(i0+9)*nao+(k0+5)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout50) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout41) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout51) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout42) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout52) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout33) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout43) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout53) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout34) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout44) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout54) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout35) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout45) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout55) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout46) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout56) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout37) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout47) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout57) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout38) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout48) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout58) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout29) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout39) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout49) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout59) * dm[(j0+0)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+3), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout41) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout42) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout43) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout44) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout45) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout46) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout47) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout48) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout49) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+4), val);
                    val = 0;
                    val += static_cast<double>(gout50) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout51) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout52) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout53) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout54) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout55) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout56) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout57) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout58) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout59) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+5), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_3020(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_3020<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_3100(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    const FloatType trr_40x = c0x * trr_30x + 3*b10 * trr_20x;
                    const FloatType hrr_3100x = trr_40x - xjxi * trr_30x;
                    gout0 += hrr_3100x * fac * wt;
                    const FloatType hrr_2100x = trr_30x - xjxi * trr_20x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_2100x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_2100x * fac * trr_10z;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += hrr_1100x * trr_20y * wt;
                    gout4 += hrr_1100x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += hrr_1100x * fac * trr_20z;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    gout6 += hrr_0100x * trr_30y * wt;
                    gout7 += hrr_0100x * trr_20y * trr_10z;
                    gout8 += hrr_0100x * trr_10y * trr_20z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    gout9 += hrr_0100x * fac * trr_30z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout10 += trr_30x * hrr_0100y * wt;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout11 += trr_20x * hrr_1100y * wt;
                    gout12 += trr_20x * hrr_0100y * trr_10z;
                    const FloatType hrr_2100y = trr_30y - yjyi * trr_20y;
                    gout13 += trr_10x * hrr_2100y * wt;
                    gout14 += trr_10x * hrr_1100y * trr_10z;
                    gout15 += trr_10x * hrr_0100y * trr_20z;
                    const FloatType trr_40y = c0y * trr_30y + 3*b10 * trr_20y;
                    const FloatType hrr_3100y = trr_40y - yjyi * trr_30y;
                    gout16 += 1 * hrr_3100y * wt;
                    gout17 += 1 * hrr_2100y * trr_10z;
                    gout18 += 1 * hrr_1100y * trr_20z;
                    gout19 += 1 * hrr_0100y * trr_30z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout20 += trr_30x * fac * hrr_0100z;
                    gout21 += trr_20x * trr_10y * hrr_0100z;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout22 += trr_20x * fac * hrr_1100z;
                    gout23 += trr_10x * trr_20y * hrr_0100z;
                    gout24 += trr_10x * trr_10y * hrr_1100z;
                    const FloatType hrr_2100z = trr_30z - zjzi * trr_20z;
                    gout25 += trr_10x * fac * hrr_2100z;
                    gout26 += 1 * trr_30y * hrr_0100z;
                    gout27 += 1 * trr_20y * hrr_1100z;
                    gout28 += 1 * trr_10y * hrr_2100z;
                    const FloatType trr_40z = c0z * trr_30z + 3*b10 * trr_20z;
                    const FloatType hrr_3100z = trr_40z - zjzi * trr_30z;
                    gout29 += 1 * fac * hrr_3100z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout29) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+9)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(i0+6)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(i0+7)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(i0+8)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+9)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout23) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+6)];
                    val += static_cast<double>(gout27) * dm[(j0+2)*nao+(i0+7)];
                    val += static_cast<double>(gout28) * dm[(j0+2)*nao+(i0+8)];
                    val += static_cast<double>(gout29) * dm[(j0+2)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+2)*nao+(k0+0)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_3100(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_3100<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_3110(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int gout_id = threadIdx.y;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *cicj_cache = (FloatType *)shared_memory;
    FloatType *rw = cicj_cache + iprim*jprim*TILE2 + sq_id;
    FloatType *gx = rw + nroots * 128;
    FloatType *gy = gx + 1024;
    FloatType *gz = gy + 1024;
    FloatType *rjri = gz + 1024;
    FloatType *rlrk = rjri + 192;
    FloatType *Rpq = rlrk + 192;

    int thread_id = 64 * gout_id + sq_id;
    int threads = 256;
    for (int n = thread_id; n < iprim*jprim*TILE2; n += threads) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        cicj_cache[sh_ij+ijp*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType s0, s1, s2;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += 64) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        if (gout_id == 0) {
            const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
            const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
            const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            rjri[0] = xjxi;
            rjri[64] = yjyi;
            rjri[128] = zjzi;
            rlrk[0] = xlxk;
            rlrk[64] = ylyk;
            rlrk[128] = zlzk;
        }
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            __syncthreads();
            if (gout_id == 0) {
                const FloatType xlxk = rlrk[0];
                const FloatType ylyk = rlrk[64];
                const FloatType zlzk = rlrk[128];
                const FloatType theta_kl = ak * al_akl;
                const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
                const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
                gx[0] = ckcl;
            }
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType aj_aij = aj / aij;
                const FloatType xij = static_cast<FloatType>(ri[0]) + rjri[0] * aj_aij;
                const FloatType yij = static_cast<FloatType>(ri[1]) + rjri[64] * aj_aij;
                const FloatType zij = static_cast<FloatType>(ri[2]) + rjri[128] * aj_aij;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + rlrk[0] * al_akl;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + rlrk[64] * al_akl;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + rlrk[128] * al_akl;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                __syncthreads();
                if (gout_id == 0) {
                    Rpq[0] = xpq;
                    Rpq[64] = ypq;
                    Rpq[128] = zpq;
                    const FloatType cicj = cicj_cache[sh_ij+ijp*TILE2];
                    gy[0] = cicj / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                }
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                __syncthreads();
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, 64, gout_id, 4);
                for (int irys = 0; irys < nroots; ++irys) {
                    __syncthreads();
                    const FloatType rt = rw[irys*128];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType rt_akl = rt_aa * aij;
                    const FloatType b00 = static_cast<FloatType>(0.5) * rt_aa;
                    for (int n = gout_id; n < 3; n += 4) {
                        if (n == 2) {
                            gz[0] = rw[irys*128+64];
                        }
                        FloatType *_gx = gx + n * 1024;
                        const FloatType xjxi = rjri[n*64];
                        const FloatType Rpa = xjxi * aj_aij;
                        const FloatType c0x = Rpa - rt_aij * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = c0x * s0;
                        _gx[64] = s1;
                        s2 = c0x * s1 + 1 * b10 * s0;
                        _gx[128] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = c0x * s1 + 2 * b10 * s0;
                        _gx[192] = s2;
                        s0 = s1;
                        s1 = s2;
                        s2 = c0x * s1 + 3 * b10 * s0;
                        _gx[256] = s2;
                        const FloatType xlxk = rlrk[n*64];
                        const FloatType Rqc = xlxk * al_akl;
                        const FloatType cpx = Rqc + rt_akl * Rpq[n*64];
                        s0 = _gx[0];
                        s1 = cpx * s0;
                        _gx[512] = s1;
                        s0 = _gx[64];
                        s1 = cpx * s0;
                        s1 += 1 * b00 * _gx[0];
                        _gx[576] = s1;
                        s0 = _gx[128];
                        s1 = cpx * s0;
                        s1 += 2 * b00 * _gx[64];
                        _gx[640] = s1;
                        s0 = _gx[192];
                        s1 = cpx * s0;
                        s1 += 3 * b00 * _gx[128];
                        _gx[704] = s1;
                        s0 = _gx[256];
                        s1 = cpx * s0;
                        s1 += 4 * b00 * _gx[192];
                        _gx[768] = s1;
                        s1 = _gx[256];
                        s0 = _gx[192];
                        _gx[448] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[128];
                        _gx[384] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[64];
                        _gx[320] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[0];
                        _gx[256] = s1 - xjxi * s0;
                        s1 = _gx[768];
                        s0 = _gx[704];
                        _gx[960] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[640];
                        _gx[896] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[576];
                        _gx[832] = s1 - xjxi * s0;
                        s1 = s0;
                        s0 = _gx[512];
                        _gx[768] = s1 - xjxi * s0;
                    }
                    __syncthreads();
                    switch (gout_id) {
                    case 0:
                    gout0 += gx[960] * gy[0] * gz[0];
                    gout1 += gx[832] * gy[64] * gz[64];
                    gout2 += gx[768] * gy[64] * gz[128];
                    gout3 += gx[640] * gy[256] * gz[64];
                    gout4 += gx[512] * gy[448] * gz[0];
                    gout5 += gx[704] * gy[0] * gz[256];
                    gout6 += gx[576] * gy[64] * gz[320];
                    gout7 += gx[512] * gy[64] * gz[384];
                    gout8 += gx[384] * gy[512] * gz[64];
                    gout9 += gx[256] * gy[704] * gz[0];
                    gout10 += gx[192] * gy[768] * gz[0];
                    gout11 += gx[64] * gy[832] * gz[64];
                    gout12 += gx[0] * gy[832] * gz[128];
                    gout13 += gx[128] * gy[512] * gz[320];
                    gout14 += gx[0] * gy[704] * gz[256];
                    gout15 += gx[448] * gy[0] * gz[512];
                    gout16 += gx[320] * gy[64] * gz[576];
                    gout17 += gx[256] * gy[64] * gz[640];
                    gout18 += gx[128] * gy[256] * gz[576];
                    gout19 += gx[0] * gy[448] * gz[512];
                    gout20 += gx[192] * gy[0] * gz[768];
                    gout21 += gx[64] * gy[64] * gz[832];
                    gout22 += gx[0] * gy[64] * gz[896];
                    break;
                    case 1:
                    gout0 += gx[896] * gy[64] * gz[0];
                    gout1 += gx[832] * gy[0] * gz[128];
                    gout2 += gx[768] * gy[0] * gz[192];
                    gout3 += gx[576] * gy[384] * gz[0];
                    gout4 += gx[512] * gy[384] * gz[64];
                    gout5 += gx[640] * gy[64] * gz[256];
                    gout6 += gx[576] * gy[0] * gz[384];
                    gout7 += gx[512] * gy[0] * gz[448];
                    gout8 += gx[320] * gy[640] * gz[0];
                    gout9 += gx[256] * gy[640] * gz[64];
                    gout10 += gx[128] * gy[832] * gz[0];
                    gout11 += gx[64] * gy[768] * gz[128];
                    gout12 += gx[0] * gy[768] * gz[192];
                    gout13 += gx[64] * gy[640] * gz[256];
                    gout14 += gx[0] * gy[640] * gz[320];
                    gout15 += gx[384] * gy[64] * gz[512];
                    gout16 += gx[320] * gy[0] * gz[640];
                    gout17 += gx[256] * gy[0] * gz[704];
                    gout18 += gx[64] * gy[384] * gz[512];
                    gout19 += gx[0] * gy[384] * gz[576];
                    gout20 += gx[128] * gy[64] * gz[768];
                    gout21 += gx[64] * gy[0] * gz[896];
                    gout22 += gx[0] * gy[0] * gz[960];
                    break;
                    case 2:
                    gout0 += gx[896] * gy[0] * gz[64];
                    gout1 += gx[768] * gy[192] * gz[0];
                    gout2 += gx[704] * gy[256] * gz[0];
                    gout3 += gx[576] * gy[320] * gz[64];
                    gout4 += gx[512] * gy[320] * gz[128];
                    gout5 += gx[640] * gy[0] * gz[320];
                    gout6 += gx[512] * gy[192] * gz[256];
                    gout7 += gx[448] * gy[512] * gz[0];
                    gout8 += gx[320] * gy[576] * gz[64];
                    gout9 += gx[256] * gy[576] * gz[128];
                    gout10 += gx[128] * gy[768] * gz[64];
                    gout11 += gx[0] * gy[960] * gz[0];
                    gout12 += gx[192] * gy[512] * gz[256];
                    gout13 += gx[64] * gy[576] * gz[320];
                    gout14 += gx[0] * gy[576] * gz[384];
                    gout15 += gx[384] * gy[0] * gz[576];
                    gout16 += gx[256] * gy[192] * gz[512];
                    gout17 += gx[192] * gy[256] * gz[512];
                    gout18 += gx[64] * gy[320] * gz[576];
                    gout19 += gx[0] * gy[320] * gz[640];
                    gout20 += gx[128] * gy[0] * gz[832];
                    gout21 += gx[0] * gy[192] * gz[768];
                    break;
                    case 3:
                    gout0 += gx[832] * gy[128] * gz[0];
                    gout1 += gx[768] * gy[128] * gz[64];
                    gout2 += gx[640] * gy[320] * gz[0];
                    gout3 += gx[576] * gy[256] * gz[128];
                    gout4 += gx[512] * gy[256] * gz[192];
                    gout5 += gx[576] * gy[128] * gz[256];
                    gout6 += gx[512] * gy[128] * gz[320];
                    gout7 += gx[384] * gy[576] * gz[0];
                    gout8 += gx[320] * gy[512] * gz[128];
                    gout9 += gx[256] * gy[512] * gz[192];
                    gout10 += gx[64] * gy[896] * gz[0];
                    gout11 += gx[0] * gy[896] * gz[64];
                    gout12 += gx[128] * gy[576] * gz[256];
                    gout13 += gx[64] * gy[512] * gz[384];
                    gout14 += gx[0] * gy[512] * gz[448];
                    gout15 += gx[320] * gy[128] * gz[512];
                    gout16 += gx[256] * gy[128] * gz[576];
                    gout17 += gx[128] * gy[320] * gz[512];
                    gout18 += gx[64] * gy[256] * gz[640];
                    gout19 += gx[0] * gy[256] * gz[704];
                    gout20 += gx[64] * gy[128] * gz[768];
                    gout21 += gx[0] * gy[128] * gz[832];
                    break;
                    }
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+6)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+6)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+8)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+8)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(i0+6)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+8)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(i0+8)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(i0+6)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+6)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+8)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+7)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+7)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+9)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+9)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+9)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(i0+7)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(i0+9)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(i0+7)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(i0+9)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+7)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+9)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+6)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+6)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+8)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+8)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(i0+8)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(i0+6)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+6)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(i0+8)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+8)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+6)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+7)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+7)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+2)];
                    atomicAdd(vj+(i0+9)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+1)];
                    atomicAdd(vj+(i0+9)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(i0+9)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(i0+7)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+9)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+7)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(i0+9)];
                    atomicAdd(vj+(k0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+9)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+7)];
                    atomicAdd(vj+(k0+2)*nao+(l0+0), val);
                    break;
                    }
                    vj += nao * nao;
                }
                if (do_k) {
                    switch (gout_id) {
                    case 0:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+8)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(i0+8)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+8)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    case 1:
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+9)*nao+(k0+2)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(i0+9)*nao+(k0+1)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout7) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+9)*nao+(k0+2)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    case 2:
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+8)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+2)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+4)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+6)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+8)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+6)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+8)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+8)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+6)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    case 3:
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+2)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(k0+1)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout1) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(k0+1)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+1)*nao+(k0+2)];
                    val += static_cast<double>(gout10) * dm[(i0+3)*nao+(k0+1)];
                    val += static_cast<double>(gout3) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+5)*nao+(k0+2)];
                    val += static_cast<double>(gout11) * dm[(i0+7)*nao+(k0+1)];
                    val += static_cast<double>(gout4) * dm[(i0+9)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(k0+2)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(k0+1)];
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(k0+2)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(k0+1)];
                    val += static_cast<double>(gout6) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+7)*nao+(k0+2)];
                    val += static_cast<double>(gout14) * dm[(i0+9)*nao+(k0+1)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+2)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+2), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+7)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+2), val);
                    break;
                    }
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_3110(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_3110<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

template<typename FloatType>
__device__ static
void _rys_jk_3200(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *shl_quartet_idx, int ntasks, int ish0, int jsh0)
{
    int sq_id = threadIdx.x;
    int nsq_per_block = blockDim.x;
    int iprim = bounds.iprim;
    int jprim = bounds.jprim;
    int kprim = bounds.kprim;
    int lprim = bounds.lprim;
    constexpr int nroots = 3;
    int *ao_loc = envs.ao_loc;
    int nbas = envs.nbas;
    int nao = ao_loc[nbas];
    int *bas = envs.bas;
    double *env = envs.env;
    extern __shared__ char shared_memory[];
    FloatType *rw_cache = (FloatType *)shared_memory;
    FloatType *rw = rw_cache + sq_id;
    FloatType *Rpa_cicj = rw_cache + nsq_per_block * nroots * 2;
    for (int n = sq_id; n < iprim*jprim*TILE2; n += nsq_per_block) {
        int ijp = n / TILE2;
        int sh_ij = n % TILE2;
        int ish = ish0 + sh_ij / TILE;
        int jsh = jsh0 + sh_ij % TILE;
        int ip = ijp / jprim;
        int jp = ijp % jprim;
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *ci = env + bas[ish*BAS_SLOTS+PTR_COEFF];
        double *cj = env + bas[jsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        const FloatType ai = static_cast<FloatType>(expi[ip]);
        const FloatType aj = static_cast<FloatType>(expj[jp]);
        const FloatType aij = ai + aj;
        const FloatType aj_aij = aj / aij;
        const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
        const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
        const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
        FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
        Rpa[sh_ij+0*TILE2] = xjxi * aj_aij;
        Rpa[sh_ij+1*TILE2] = yjyi * aj_aij;
        Rpa[sh_ij+2*TILE2] = zjzi * aj_aij;
        const FloatType theta_ij = ai * aj / aij;
        const FloatType Kab = MixedPrecisionOperator<FloatType>::fp_exp(-theta_ij * (xjxi*xjxi+yjyi*yjyi+zjzi*zjzi));
        Rpa[sh_ij+3*TILE2] = static_cast<FloatType>(ci[ip]) * static_cast<FloatType>(cj[jp]) * Kab;
    }
    FloatType gout0;
    FloatType gout1;
    FloatType gout2;
    FloatType gout3;
    FloatType gout4;
    FloatType gout5;
    FloatType gout6;
    FloatType gout7;
    FloatType gout8;
    FloatType gout9;
    FloatType gout10;
    FloatType gout11;
    FloatType gout12;
    FloatType gout13;
    FloatType gout14;
    FloatType gout15;
    FloatType gout16;
    FloatType gout17;
    FloatType gout18;
    FloatType gout19;
    FloatType gout20;
    FloatType gout21;
    FloatType gout22;
    FloatType gout23;
    FloatType gout24;
    FloatType gout25;
    FloatType gout26;
    FloatType gout27;
    FloatType gout28;
    FloatType gout29;
    FloatType gout30;
    FloatType gout31;
    FloatType gout32;
    FloatType gout33;
    FloatType gout34;
    FloatType gout35;
    FloatType gout36;
    FloatType gout37;
    FloatType gout38;
    FloatType gout39;
    FloatType gout40;
    FloatType gout41;
    FloatType gout42;
    FloatType gout43;
    FloatType gout44;
    FloatType gout45;
    FloatType gout46;
    FloatType gout47;
    FloatType gout48;
    FloatType gout49;
    FloatType gout50;
    FloatType gout51;
    FloatType gout52;
    FloatType gout53;
    FloatType gout54;
    FloatType gout55;
    FloatType gout56;
    FloatType gout57;
    FloatType gout58;
    FloatType gout59;
    double val;
    double *dm, *vj, *vk;

    for (int task0 = 0; task0 < ntasks; task0 += nsq_per_block) {
        __syncthreads();
        int task_id = task0 + sq_id;
        FloatType fac_sym = static_cast<FloatType>(PI_FAC);
        ShellQuartet sq;
        if (task_id >= ntasks) {
            // To avoid __syncthreads blocking blocking idle warps, all remaining
            // threads compute a valid shell quartet with zero normalization factor
            sq = shl_quartet_idx[0];
            fac_sym = 0;
        } else {
            sq = shl_quartet_idx[task_id];
        }
        int ish = sq.i;
        int jsh = sq.j;
        int ksh = sq.k;
        int lsh = sq.l;
        int sh_ij = (ish % TILE) * TILE + (jsh % TILE);
        if (ish == jsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ksh == lsh) fac_sym *= static_cast<FloatType>(0.5);
        if (ish*nbas+jsh == ksh*nbas+lsh) fac_sym *= static_cast<FloatType>(0.5);
        int i0 = ao_loc[ish];
        int j0 = ao_loc[jsh];
        int k0 = ao_loc[ksh];
        int l0 = ao_loc[lsh];
        double *expi = env + bas[ish*BAS_SLOTS+PTR_EXP];
        double *expj = env + bas[jsh*BAS_SLOTS+PTR_EXP];
        double *expk = env + bas[ksh*BAS_SLOTS+PTR_EXP];
        double *expl = env + bas[lsh*BAS_SLOTS+PTR_EXP];
        double *ck = env + bas[ksh*BAS_SLOTS+PTR_COEFF];
        double *cl = env + bas[lsh*BAS_SLOTS+PTR_COEFF];
        double *ri = env + bas[ish*BAS_SLOTS+PTR_BAS_COORD];
        double *rj = env + bas[jsh*BAS_SLOTS+PTR_BAS_COORD];
        double *rk = env + bas[ksh*BAS_SLOTS+PTR_BAS_COORD];
        double *rl = env + bas[lsh*BAS_SLOTS+PTR_BAS_COORD];
        
        gout0 = 0;
        gout1 = 0;
        gout2 = 0;
        gout3 = 0;
        gout4 = 0;
        gout5 = 0;
        gout6 = 0;
        gout7 = 0;
        gout8 = 0;
        gout9 = 0;
        gout10 = 0;
        gout11 = 0;
        gout12 = 0;
        gout13 = 0;
        gout14 = 0;
        gout15 = 0;
        gout16 = 0;
        gout17 = 0;
        gout18 = 0;
        gout19 = 0;
        gout20 = 0;
        gout21 = 0;
        gout22 = 0;
        gout23 = 0;
        gout24 = 0;
        gout25 = 0;
        gout26 = 0;
        gout27 = 0;
        gout28 = 0;
        gout29 = 0;
        gout30 = 0;
        gout31 = 0;
        gout32 = 0;
        gout33 = 0;
        gout34 = 0;
        gout35 = 0;
        gout36 = 0;
        gout37 = 0;
        gout38 = 0;
        gout39 = 0;
        gout40 = 0;
        gout41 = 0;
        gout42 = 0;
        gout43 = 0;
        gout44 = 0;
        gout45 = 0;
        gout46 = 0;
        gout47 = 0;
        gout48 = 0;
        gout49 = 0;
        gout50 = 0;
        gout51 = 0;
        gout52 = 0;
        gout53 = 0;
        gout54 = 0;
        gout55 = 0;
        gout56 = 0;
        gout57 = 0;
        gout58 = 0;
        gout59 = 0;
        for (int klp = 0; klp < kprim*lprim; ++klp) {
            int kp = klp / lprim;
            int lp = klp % lprim;
            const FloatType ak = static_cast<FloatType>(expk[kp]);
            const FloatType al = static_cast<FloatType>(expl[lp]);
            const FloatType akl = ak + al;
            const FloatType al_akl = al / akl;
            const FloatType xlxk = static_cast<FloatType>(rl[0]) - static_cast<FloatType>(rk[0]);
            const FloatType ylyk = static_cast<FloatType>(rl[1]) - static_cast<FloatType>(rk[1]);
            const FloatType zlzk = static_cast<FloatType>(rl[2]) - static_cast<FloatType>(rk[2]);
            const FloatType theta_kl = ak * al_akl;
            const FloatType Kcd = MixedPrecisionOperator<FloatType>::fp_exp(-theta_kl * (xlxk*xlxk+ylyk*ylyk+zlzk*zlzk));
            const FloatType ckcl = fac_sym * static_cast<FloatType>(ck[kp]) * static_cast<FloatType>(cl[lp]) * Kcd;
            for (int ijp = 0; ijp < iprim*jprim; ++ijp) {
                int ip = ijp / jprim;
                int jp = ijp % jprim;
                const FloatType ai = static_cast<FloatType>(expi[ip]);
                const FloatType aj = static_cast<FloatType>(expj[jp]);
                const FloatType aij = ai + aj;
                const FloatType xjxi = static_cast<FloatType>(rj[0]) - static_cast<FloatType>(ri[0]);
                const FloatType yjyi = static_cast<FloatType>(rj[1]) - static_cast<FloatType>(ri[1]);
                const FloatType zjzi = static_cast<FloatType>(rj[2]) - static_cast<FloatType>(ri[2]);
                FloatType *Rpa = Rpa_cicj + ijp * TILE2*4;
                const FloatType cicj = Rpa[sh_ij+3*TILE2];
                const FloatType fac = cicj * ckcl / (aij*akl* MixedPrecisionOperator<FloatType>::fp_sqrt(aij+akl));
                const FloatType xpa = Rpa[sh_ij+0*TILE2];
                const FloatType ypa = Rpa[sh_ij+1*TILE2];
                const FloatType zpa = Rpa[sh_ij+2*TILE2];
                const FloatType xij = static_cast<FloatType>(ri[0]) + xpa;
                const FloatType yij = static_cast<FloatType>(ri[1]) + ypa;
                const FloatType zij = static_cast<FloatType>(ri[2]) + zpa;
                const FloatType xqc = xlxk * al_akl; // (ak*xk+al*xl)/akl
                const FloatType yqc = ylyk * al_akl;
                const FloatType zqc = zlzk * al_akl;
                const FloatType xkl = static_cast<FloatType>(rk[0]) + xqc;
                const FloatType ykl = static_cast<FloatType>(rk[1]) + yqc;
                const FloatType zkl = static_cast<FloatType>(rk[2]) + zqc;
                const FloatType xpq = xij - xkl;
                const FloatType ypq = yij - ykl;
                const FloatType zpq = zij - zkl;
                const FloatType theta = aij * akl / (aij + akl);
                const FloatType rr = xpq * xpq + ypq * ypq + zpq * zpq;
                const FloatType omega = static_cast<FloatType>(env[PTR_RANGE_OMEGA]);
                rys_roots_rs_mixed_precision<FloatType>(nroots, theta, rr, omega, rw, nsq_per_block, 0, 1);
                if (task_id >= ntasks) {
                    continue;
                }
                for (int irys = 0; irys < nroots; ++irys) {
                    const FloatType wt = rw[(2*irys+1)*nsq_per_block];
                    const FloatType rt = rw[ 2*irys   *nsq_per_block];
                    const FloatType rt_aa = rt / (aij + akl);
                    const FloatType rt_aij = rt_aa * akl;
                    const FloatType b10 = static_cast<FloatType>(0.5)/aij * (static_cast<FloatType>(1.0) - rt_aij);
                    const FloatType c0x = Rpa[sh_ij+0*TILE2] - xpq*rt_aij;
                    const FloatType trr_10x = c0x * 1;
                    const FloatType trr_20x = c0x * trr_10x + 1*b10 * 1;
                    const FloatType trr_30x = c0x * trr_20x + 2*b10 * trr_10x;
                    const FloatType trr_40x = c0x * trr_30x + 3*b10 * trr_20x;
                    const FloatType trr_50x = c0x * trr_40x + 4*b10 * trr_30x;
                    const FloatType hrr_4100x = trr_50x - xjxi * trr_40x;
                    const FloatType hrr_3100x = trr_40x - xjxi * trr_30x;
                    const FloatType hrr_3200x = hrr_4100x - xjxi * hrr_3100x;
                    gout0 += hrr_3200x * fac * wt;
                    const FloatType hrr_2100x = trr_30x - xjxi * trr_20x;
                    const FloatType hrr_2200x = hrr_3100x - xjxi * hrr_2100x;
                    const FloatType c0y = Rpa[sh_ij+1*TILE2] - ypq*rt_aij;
                    const FloatType trr_10y = c0y * fac;
                    gout1 += hrr_2200x * trr_10y * wt;
                    const FloatType c0z = Rpa[sh_ij+2*TILE2] - zpq*rt_aij;
                    const FloatType trr_10z = c0z * wt;
                    gout2 += hrr_2200x * fac * trr_10z;
                    const FloatType hrr_1100x = trr_20x - xjxi * trr_10x;
                    const FloatType hrr_1200x = hrr_2100x - xjxi * hrr_1100x;
                    const FloatType trr_20y = c0y * trr_10y + 1*b10 * fac;
                    gout3 += hrr_1200x * trr_20y * wt;
                    gout4 += hrr_1200x * trr_10y * trr_10z;
                    const FloatType trr_20z = c0z * trr_10z + 1*b10 * wt;
                    gout5 += hrr_1200x * fac * trr_20z;
                    const FloatType hrr_0100x = trr_10x - xjxi * 1;
                    const FloatType hrr_0200x = hrr_1100x - xjxi * hrr_0100x;
                    const FloatType trr_30y = c0y * trr_20y + 2*b10 * trr_10y;
                    gout6 += hrr_0200x * trr_30y * wt;
                    gout7 += hrr_0200x * trr_20y * trr_10z;
                    gout8 += hrr_0200x * trr_10y * trr_20z;
                    const FloatType trr_30z = c0z * trr_20z + 2*b10 * trr_10z;
                    gout9 += hrr_0200x * fac * trr_30z;
                    const FloatType hrr_0100y = trr_10y - yjyi * fac;
                    gout10 += hrr_3100x * hrr_0100y * wt;
                    const FloatType hrr_1100y = trr_20y - yjyi * trr_10y;
                    gout11 += hrr_2100x * hrr_1100y * wt;
                    gout12 += hrr_2100x * hrr_0100y * trr_10z;
                    const FloatType hrr_2100y = trr_30y - yjyi * trr_20y;
                    gout13 += hrr_1100x * hrr_2100y * wt;
                    gout14 += hrr_1100x * hrr_1100y * trr_10z;
                    gout15 += hrr_1100x * hrr_0100y * trr_20z;
                    const FloatType trr_40y = c0y * trr_30y + 3*b10 * trr_20y;
                    const FloatType hrr_3100y = trr_40y - yjyi * trr_30y;
                    gout16 += hrr_0100x * hrr_3100y * wt;
                    gout17 += hrr_0100x * hrr_2100y * trr_10z;
                    gout18 += hrr_0100x * hrr_1100y * trr_20z;
                    gout19 += hrr_0100x * hrr_0100y * trr_30z;
                    const FloatType hrr_0100z = trr_10z - zjzi * wt;
                    gout20 += hrr_3100x * fac * hrr_0100z;
                    gout21 += hrr_2100x * trr_10y * hrr_0100z;
                    const FloatType hrr_1100z = trr_20z - zjzi * trr_10z;
                    gout22 += hrr_2100x * fac * hrr_1100z;
                    gout23 += hrr_1100x * trr_20y * hrr_0100z;
                    gout24 += hrr_1100x * trr_10y * hrr_1100z;
                    const FloatType hrr_2100z = trr_30z - zjzi * trr_20z;
                    gout25 += hrr_1100x * fac * hrr_2100z;
                    gout26 += hrr_0100x * trr_30y * hrr_0100z;
                    gout27 += hrr_0100x * trr_20y * hrr_1100z;
                    gout28 += hrr_0100x * trr_10y * hrr_2100z;
                    const FloatType trr_40z = c0z * trr_30z + 3*b10 * trr_20z;
                    const FloatType hrr_3100z = trr_40z - zjzi * trr_30z;
                    gout29 += hrr_0100x * fac * hrr_3100z;
                    const FloatType hrr_0200y = hrr_1100y - yjyi * hrr_0100y;
                    gout30 += trr_30x * hrr_0200y * wt;
                    const FloatType hrr_1200y = hrr_2100y - yjyi * hrr_1100y;
                    gout31 += trr_20x * hrr_1200y * wt;
                    gout32 += trr_20x * hrr_0200y * trr_10z;
                    const FloatType hrr_2200y = hrr_3100y - yjyi * hrr_2100y;
                    gout33 += trr_10x * hrr_2200y * wt;
                    gout34 += trr_10x * hrr_1200y * trr_10z;
                    gout35 += trr_10x * hrr_0200y * trr_20z;
                    const FloatType trr_50y = c0y * trr_40y + 4*b10 * trr_30y;
                    const FloatType hrr_4100y = trr_50y - yjyi * trr_40y;
                    const FloatType hrr_3200y = hrr_4100y - yjyi * hrr_3100y;
                    gout36 += 1 * hrr_3200y * wt;
                    gout37 += 1 * hrr_2200y * trr_10z;
                    gout38 += 1 * hrr_1200y * trr_20z;
                    gout39 += 1 * hrr_0200y * trr_30z;
                    gout40 += trr_30x * hrr_0100y * hrr_0100z;
                    gout41 += trr_20x * hrr_1100y * hrr_0100z;
                    gout42 += trr_20x * hrr_0100y * hrr_1100z;
                    gout43 += trr_10x * hrr_2100y * hrr_0100z;
                    gout44 += trr_10x * hrr_1100y * hrr_1100z;
                    gout45 += trr_10x * hrr_0100y * hrr_2100z;
                    gout46 += 1 * hrr_3100y * hrr_0100z;
                    gout47 += 1 * hrr_2100y * hrr_1100z;
                    gout48 += 1 * hrr_1100y * hrr_2100z;
                    gout49 += 1 * hrr_0100y * hrr_3100z;
                    const FloatType hrr_0200z = hrr_1100z - zjzi * hrr_0100z;
                    gout50 += trr_30x * fac * hrr_0200z;
                    gout51 += trr_20x * trr_10y * hrr_0200z;
                    const FloatType hrr_1200z = hrr_2100z - zjzi * hrr_1100z;
                    gout52 += trr_20x * fac * hrr_1200z;
                    gout53 += trr_10x * trr_20y * hrr_0200z;
                    gout54 += trr_10x * trr_10y * hrr_1200z;
                    const FloatType hrr_2200z = hrr_3100z - zjzi * hrr_2100z;
                    gout55 += trr_10x * fac * hrr_2200z;
                    gout56 += 1 * trr_30y * hrr_0200z;
                    gout57 += 1 * trr_20y * hrr_1200z;
                    gout58 += 1 * trr_10y * hrr_2200z;
                    const FloatType trr_50z = c0z * trr_40z + 4*b10 * trr_30z;
                    const FloatType hrr_4100z = trr_50z - zjzi * trr_40z;
                    const FloatType hrr_3200z = hrr_4100z - zjzi * hrr_3100z;
                    gout59 += 1 * fac * hrr_3200z;
                }
            }
        }
        if (task_id < ntasks) {
            dm = jk.dm;
            vj = jk.vj;
            vk = jk.vk;
            int do_j = vj != NULL;
            int do_k = vk != NULL;
            for (int i_dm = 0; i_dm < jk.n_dm; ++i_dm) {
                if (do_j) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout50) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+0)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout11) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout21) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout31) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout41) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout51) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+1)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout12) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout22) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout32) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout42) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout52) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+2)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout13) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout23) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout33) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout43) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout53) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+3)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout14) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout24) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout34) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout44) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout54) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+4)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout15) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout25) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout35) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout45) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout55) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+5)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout16) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout26) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout36) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout46) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout56) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+6)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout17) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout27) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout37) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout47) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout57) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+7)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout18) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout28) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout38) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout48) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout58) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+8)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+0), val);
                    val = 0;
                    val += static_cast<double>(gout19) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+1), val);
                    val = 0;
                    val += static_cast<double>(gout29) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+2), val);
                    val = 0;
                    val += static_cast<double>(gout39) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+3), val);
                    val = 0;
                    val += static_cast<double>(gout49) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+4), val);
                    val = 0;
                    val += static_cast<double>(gout59) * dm[(l0+0)*nao+(k0+0)];
                    atomicAdd(vj+(i0+9)*nao+(j0+5), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(i0+0)];
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(i0+1)];
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(i0+2)];
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(i0+3)];
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(i0+4)];
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(i0+5)];
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(i0+6)];
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(i0+7)];
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(i0+8)];
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(i0+9)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(i0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(i0+1)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(i0+2)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(i0+3)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(i0+4)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(i0+5)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(i0+6)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(i0+7)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(i0+8)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(i0+9)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(i0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(i0+1)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(i0+2)];
                    val += static_cast<double>(gout23) * dm[(j0+2)*nao+(i0+3)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(i0+4)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(i0+5)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(i0+6)];
                    val += static_cast<double>(gout27) * dm[(j0+2)*nao+(i0+7)];
                    val += static_cast<double>(gout28) * dm[(j0+2)*nao+(i0+8)];
                    val += static_cast<double>(gout29) * dm[(j0+2)*nao+(i0+9)];
                    val += static_cast<double>(gout30) * dm[(j0+3)*nao+(i0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+3)*nao+(i0+1)];
                    val += static_cast<double>(gout32) * dm[(j0+3)*nao+(i0+2)];
                    val += static_cast<double>(gout33) * dm[(j0+3)*nao+(i0+3)];
                    val += static_cast<double>(gout34) * dm[(j0+3)*nao+(i0+4)];
                    val += static_cast<double>(gout35) * dm[(j0+3)*nao+(i0+5)];
                    val += static_cast<double>(gout36) * dm[(j0+3)*nao+(i0+6)];
                    val += static_cast<double>(gout37) * dm[(j0+3)*nao+(i0+7)];
                    val += static_cast<double>(gout38) * dm[(j0+3)*nao+(i0+8)];
                    val += static_cast<double>(gout39) * dm[(j0+3)*nao+(i0+9)];
                    val += static_cast<double>(gout40) * dm[(j0+4)*nao+(i0+0)];
                    val += static_cast<double>(gout41) * dm[(j0+4)*nao+(i0+1)];
                    val += static_cast<double>(gout42) * dm[(j0+4)*nao+(i0+2)];
                    val += static_cast<double>(gout43) * dm[(j0+4)*nao+(i0+3)];
                    val += static_cast<double>(gout44) * dm[(j0+4)*nao+(i0+4)];
                    val += static_cast<double>(gout45) * dm[(j0+4)*nao+(i0+5)];
                    val += static_cast<double>(gout46) * dm[(j0+4)*nao+(i0+6)];
                    val += static_cast<double>(gout47) * dm[(j0+4)*nao+(i0+7)];
                    val += static_cast<double>(gout48) * dm[(j0+4)*nao+(i0+8)];
                    val += static_cast<double>(gout49) * dm[(j0+4)*nao+(i0+9)];
                    val += static_cast<double>(gout50) * dm[(j0+5)*nao+(i0+0)];
                    val += static_cast<double>(gout51) * dm[(j0+5)*nao+(i0+1)];
                    val += static_cast<double>(gout52) * dm[(j0+5)*nao+(i0+2)];
                    val += static_cast<double>(gout53) * dm[(j0+5)*nao+(i0+3)];
                    val += static_cast<double>(gout54) * dm[(j0+5)*nao+(i0+4)];
                    val += static_cast<double>(gout55) * dm[(j0+5)*nao+(i0+5)];
                    val += static_cast<double>(gout56) * dm[(j0+5)*nao+(i0+6)];
                    val += static_cast<double>(gout57) * dm[(j0+5)*nao+(i0+7)];
                    val += static_cast<double>(gout58) * dm[(j0+5)*nao+(i0+8)];
                    val += static_cast<double>(gout59) * dm[(j0+5)*nao+(i0+9)];
                    atomicAdd(vj+(k0+0)*nao+(l0+0), val);
                    vj += nao * nao;
                }
                if (do_k) {
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout50) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout41) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout51) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout52) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout53) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout54) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout45) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout55) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout46) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout56) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+6)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout47) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout57) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+7)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout48) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout58) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+8)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout49) * dm[(j0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout59) * dm[(j0+5)*nao+(k0+0)];
                    atomicAdd(vk+(i0+9)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+0)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+1)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+2)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+3)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout41) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout42) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout43) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout44) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout45) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout46) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout47) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout48) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout49) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+4)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout50) * dm[(i0+0)*nao+(k0+0)];
                    val += static_cast<double>(gout51) * dm[(i0+1)*nao+(k0+0)];
                    val += static_cast<double>(gout52) * dm[(i0+2)*nao+(k0+0)];
                    val += static_cast<double>(gout53) * dm[(i0+3)*nao+(k0+0)];
                    val += static_cast<double>(gout54) * dm[(i0+4)*nao+(k0+0)];
                    val += static_cast<double>(gout55) * dm[(i0+5)*nao+(k0+0)];
                    val += static_cast<double>(gout56) * dm[(i0+6)*nao+(k0+0)];
                    val += static_cast<double>(gout57) * dm[(i0+7)*nao+(k0+0)];
                    val += static_cast<double>(gout58) * dm[(i0+8)*nao+(k0+0)];
                    val += static_cast<double>(gout59) * dm[(i0+9)*nao+(k0+0)];
                    atomicAdd(vk+(j0+5)*nao+(l0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout10) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout20) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout30) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout40) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout50) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout1) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout41) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout51) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout2) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout42) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout52) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout3) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout43) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout53) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout4) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout44) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout54) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout5) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout45) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout55) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+5)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout6) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout46) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout56) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+6)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout7) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout47) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout57) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+7)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout8) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout48) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout58) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+8)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout9) * dm[(j0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(j0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(j0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(j0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout49) * dm[(j0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout59) * dm[(j0+5)*nao+(l0+0)];
                    atomicAdd(vk+(i0+9)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout0) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout1) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout2) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout3) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout4) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout5) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout6) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout7) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout8) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout9) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+0)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout10) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout11) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout12) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout13) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout14) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout15) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout16) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout17) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout18) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout19) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+1)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout20) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout21) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout22) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout23) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout24) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout25) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout26) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout27) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout28) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout29) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+2)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout30) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout31) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout32) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout33) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout34) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout35) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout36) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout37) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout38) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout39) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+3)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout40) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout41) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout42) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout43) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout44) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout45) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout46) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout47) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout48) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout49) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+4)*nao+(k0+0), val);
                    val = 0;
                    val += static_cast<double>(gout50) * dm[(i0+0)*nao+(l0+0)];
                    val += static_cast<double>(gout51) * dm[(i0+1)*nao+(l0+0)];
                    val += static_cast<double>(gout52) * dm[(i0+2)*nao+(l0+0)];
                    val += static_cast<double>(gout53) * dm[(i0+3)*nao+(l0+0)];
                    val += static_cast<double>(gout54) * dm[(i0+4)*nao+(l0+0)];
                    val += static_cast<double>(gout55) * dm[(i0+5)*nao+(l0+0)];
                    val += static_cast<double>(gout56) * dm[(i0+6)*nao+(l0+0)];
                    val += static_cast<double>(gout57) * dm[(i0+7)*nao+(l0+0)];
                    val += static_cast<double>(gout58) * dm[(i0+8)*nao+(l0+0)];
                    val += static_cast<double>(gout59) * dm[(i0+9)*nao+(l0+0)];
                    atomicAdd(vk+(j0+5)*nao+(k0+0), val);
                    vk += nao * nao;
                }
                dm += nao * nao;
            }
        }
    }
}
template<typename FloatType>
__global__
static void rys_jk_3200(RysIntEnvVars envs, JKMatrix jk, BoundsInfo bounds,
                ShellQuartet *pool, uint32_t *batch_head)
{
    int b_id = blockIdx.x;
    int t_id = threadIdx.x + blockDim.x * threadIdx.y;
    ShellQuartet *shl_quartet_idx = pool + b_id * QUEUE_DEPTH;
    extern __shared__ int batch_id[];
    if (t_id == 0) {
        batch_id[0] = atomicAdd(batch_head, 1);
    }
    __syncthreads();
    int nbatches_kl = (bounds.ntile_kl_pairs + TILES_IN_BATCH - 1) / TILES_IN_BATCH;
    int nbatches = bounds.ntile_ij_pairs * nbatches_kl;
    while (batch_id[0] < nbatches) {
        int batch_ij = batch_id[0] / nbatches_kl;
        int batch_kl = batch_id[0] % nbatches_kl;
        double omega = envs.env[PTR_RANGE_OMEGA];
        int ntasks;
        if (omega >= 0) {
            ntasks = _fill_jk_tasks_mixed_precision<FloatType>(shl_quartet_idx, envs, jk.vj != NULL, jk.vk != NULL,
                                                               bounds, batch_ij, batch_kl);
        } else {
            ntasks = _fill_sr_jk_tasks(shl_quartet_idx, envs, jk, bounds,
                                       batch_ij, batch_kl);
        }
        if (ntasks > 0) {
            int tile_ij = bounds.tile_ij_mapping[batch_ij];
            int nbas = envs.nbas;
            int nbas_tiles = nbas / TILE;
            int tile_i = tile_ij / nbas_tiles;
            int tile_j = tile_ij % nbas_tiles;
            int ish0 = tile_i * TILE;
            int jsh0 = tile_j * TILE;
            _rys_jk_3200<FloatType>(envs, jk, bounds, shl_quartet_idx, ntasks, ish0, jsh0);
            __syncthreads();
        }
        if (t_id == 0) {
            batch_id[0] = atomicAdd(batch_head, 1);
            atomicAdd(batch_head+1, ntasks);
        }
        __syncthreads();
    }
}

int rys_jk_unrolled(RysIntEnvVars *envs, JKMatrix *jk, BoundsInfo *bounds,
                    ShellQuartet *pool, uint32_t *batch_head, int *scheme, int workers)
{
    int li = bounds->li;
    int lj = bounds->lj;
    int lk = bounds->lk;
    int ll = bounds->ll;
    int ijkl = li*125 + lj*25 + lk*5 + ll;
    int nroots = bounds->nroots;
    int iprim = bounds->iprim;
    int jprim = bounds->jprim;
    int ij_prims = iprim * jprim;
    int buflen = ij_prims*TILE2;
    int nsq_per_block = 256;
    int gout_stride = 1;

    switch (ijkl) {
    case 261:
        nsq_per_block = 64;
        gout_stride = 4;
        break;
    case 281:
        nsq_per_block = 64;
        gout_stride = 4;
        break;
    case 285:
        nsq_per_block = 64;
        gout_stride = 4;
        break;
    case 305:
        nsq_per_block = 64;
        gout_stride = 4;
        break;
    case 381:
        nsq_per_block = 64;
        gout_stride = 4;
        break;
    case 405:
        nsq_per_block = 64;
        gout_stride = 4;
        break;
    }

#if CUDA_VERSION >= 12040
    switch (ijkl) {
    case 0: nsq_per_block *= 2; break;
    case 125: nsq_per_block *= 2; break;
    case 130: nsq_per_block *= 2; break;
    case 150: nsq_per_block *= 2; break;
    case 250: nsq_per_block *= 2; break;
    case 255: nsq_per_block *= 2; break;
    case 275: nsq_per_block *= 2; break;
    case 375: nsq_per_block *= 2; break;
    }
#endif

    dim3 threads(nsq_per_block, gout_stride);
    buflen += nroots*2 * nsq_per_block;
    switch (ijkl) {
    case 0:
        buflen += ij_prims*TILE2*3;
        rys_jk_0000<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_0000< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 125:
        buflen += ij_prims*TILE2*3;
        rys_jk_1000<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_1000< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 130:
        buflen += ij_prims*TILE2*3;
        rys_jk_1010<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_1010< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 131:
        buflen += ij_prims*TILE2*3;
        rys_jk_1011<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_1011< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 150:
        buflen += ij_prims*TILE2*3;
        rys_jk_1100<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_1100< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 155:
        buflen += ij_prims*TILE2*3;
        rys_jk_1110<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_1110< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 156:
        buflen += ij_prims*TILE2*3;
        rys_jk_1111<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_1111< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 250:
        buflen += ij_prims*TILE2*3;
        rys_jk_2000<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2000< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 255:
        buflen += ij_prims*TILE2*3;
        rys_jk_2010<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2010< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 256:
        buflen += ij_prims*TILE2*3;
        rys_jk_2011<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2011< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 260:
        buflen += ij_prims*TILE2*3;
        rys_jk_2020<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2020< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 261:
        buflen += 4032;
        rys_jk_2021<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2021< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 275:
        buflen += ij_prims*TILE2*3;
        rys_jk_2100<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2100< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 280:
        buflen += ij_prims*TILE2*3;
        rys_jk_2110<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2110< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 281:
        buflen += 5184;
        cudaFuncSetAttribute(rys_jk_2111<double>, cudaFuncAttributeMaxDynamicSharedMemorySize, buflen*sizeof(double));
        cudaFuncSetAttribute(rys_jk_2111< float>, cudaFuncAttributeMaxDynamicSharedMemorySize, buflen*sizeof( float));
        rys_jk_2111<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2111< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 285:
        buflen += 4032;
        rys_jk_2120<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2120< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 300:
        buflen += ij_prims*TILE2*3;
        rys_jk_2200<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2200< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 305:
        buflen += 4032;
        rys_jk_2210<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_2210< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 375:
        buflen += ij_prims*TILE2*3;
        rys_jk_3000<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_3000< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 380:
        buflen += ij_prims*TILE2*3;
        rys_jk_3010<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_3010< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 381:
        buflen += 3648;
        rys_jk_3011<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_3011< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 385:
        buflen += ij_prims*TILE2*3;
        rys_jk_3020<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_3020< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 400:
        buflen += ij_prims*TILE2*3;
        rys_jk_3100<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_3100< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 405:
        buflen += 3648;
        rys_jk_3110<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_3110< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    case 425:
        buflen += ij_prims*TILE2*3;
        rys_jk_3200<double> <<<workers, threads, buflen*sizeof(double)>>>(*envs, *jk, *bounds, pool, batch_head);
        cudaMemset(batch_head, 0, 2*sizeof(uint32_t));
        rys_jk_3200< float> <<<workers, threads, buflen*sizeof( float)>>>(*envs, *jk, *bounds, pool, batch_head);
        break;
    default: return 0;
    }
    return 1;
}
